---
title: python 异步IO
date: 2022-02-22 10:23:50
tags:
- python
categories:
- 编程
- python
---

相比于多线程，协程或者叫微线程(coroutine)，这样的方式效率更高，因为没有切换线程的开销，不存在变量冲突和进程锁等限制。
因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。

```py
import threading
import asyncio


async def print_thread(th):
    return str(th)[2:6]


async def hello():
    print('Hello world! (%s)' % threading.currentThread())
    r = await print_thread(threading.currentThread())
    print('Hello %s' % r)
    await asyncio.sleep(1)
    print('Hello again! (%s)' % threading.currentThread())

loop = asyncio.get_event_loop()
tasks = [hello(), hello()]
loop.run_until_complete(asyncio.wait(tasks))
loop.close()
```

执行结果

```
Hello world! (<_MainThread(MainThread, started 12448)>)
Hello Main
Hello world! (<_MainThread(MainThread, started 12448)>)
Hello Main
(暂停1秒)
Hello again! (<_MainThread(MainThread, started 12448)>)
Hello again! (<_MainThread(MainThread, started 12448)>)
```

可以看到，使用的是一个进程。

1. `async`标记把一个`generator`标记为`coroutine`类型
2. 从`asyncio`模块中直接获取一个`EventLoop`的引用，然后把需要执行的协程扔到`EventLoop`中执行，就实现了异步IO。
3. `await` 等同于 `yeild from`
