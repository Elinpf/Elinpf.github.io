---
title: python 有趣的代码片段收集
date: 2022-03-10 14:32:58
top: 10
tags:
- python
- 收集
- todo
categories:
- 编程
- python
---

本篇为阅读源码时看到的一些有趣的代码，有所改变后记录

## 使用二进制作为选项判断

这是在`Rich`中看到的一段, 用`sum`总和，得到那些参数为真

```py
self._set_attributes = sum(
    (
        bold is not None,
        dim is not None and 2,
        italic is not None and 4,
        underline is not None and 8,
        blink is not None and 16,
        blink2 is not None and 32,
        reverse is not None and 64,
        conceal is not None and 128,
        strike is not None and 256,
        underline2 is not None and 512,
        frame is not None and 1024,
        encircle is not None and 2048,
        overline is not None and 4096,
    )
)
self._attributes = (
    sum(
        (
            bold and 1 or 0,
            dim and 2 or 0,
            italic and 4 or 0,
            underline and 8 or 0,
            blink and 16 or 0,
            blink2 and 32 or 0,
            reverse and 64 or 0,
            conceal and 128 or 0,
            strike and 256 or 0,
            underline2 and 512 or 0,
            frame and 1024 or 0,
            encircle and 2048 or 0,
            overline and 4096 or 0,
        )
    )
```

## 灵活运用or

灵活运用or可以做到参数里面

```py
 render_options = render_options.update_dimensions(
                render_options.max_width, render_options.height or self.height
            )
```

## 使用自定义类来判断是否写了参数

```py
class NoChange:
pass

NO_CHANGE = NoChange()

 def update(
        self,
        *,
        width: Union[int, NoChange] = NO_CHANGE,
        min_width: Union[int, NoChange] = NO_CHANGE
 ):
    if not isinstance(width, NoChange):
        options.min_width = options.max_width = max(0, width)
    if not isinstance(min_width, NoChange):
        options.min_width = min_width
```

## 单行 if...else

```py
print('a') if True else print('b')
```
or 

```py
print('a'
      if True
      else 'b')
``` 

配合 for 循环

```py
_layouts = [
    layout if isinstance(layout, Layout) else Layout(layout)
    for layout in layouts
]
```

## lambda 作为参数

```py
from typing import Callable

def test_lambda(code: Callable):
    print(type(code))
    if isinstance(code, Callable):
        print("code is callable")
        print(code())

code = 1

test_lambda(code=lambda: str(code or ''))

## output:
#<class 'function'>
#str is callable
#1
```

## print 中的`!r`

```py
pwd='123456'
print(f"password={pwd!r}")

## output:
#password='123456'
```

会将内容用引号包括住


## 多个 contentmanager 一起写

```py
with Popen("command", stdout=PIPE, stderr=STDOUT, bufsize=1) as p, \
     open('logfile', 'ab') as file:
    for line in p.stdout: # b'\n'-separated lines
        sys.stdout.buffer.write(line) # pass bytes as is
        file.write(line)
```

## 使用`__file__`定位程序的路径

```py
import os
from . import __file__ as module_file

self.root_path = os.path.dirname(module_file)
```

## 正则表达式的扩展

希望逐字匹配的时候。

当遇到`show version`的时候，需要匹配`sh[[ow]] ver[[sion]]`这样写

```py
def _PreParse(self, key, value):
"""Executed against each field of each row read from index table."""
if key == 'Command':
    return re.sub(r'(\[\[.+?\]\])', self._Completion, value)
else:
    return value

def _Completion(self, match):
r"""Replaces double square brackets with variable length completion.

Completion cannot be mixed with regexp matching or '\' characters
i.e. '[[(\n)]] would become (\(n)?)?.'

Args:
    match: A regex Match() object.

Returns:
    String of the format '(a(b(c(d)?)?)?)?'.
"""
# Strip the outer '[[' & ']]' and replace with ()? regexp pattern.
word = str(match.group())[2:-2]
return '(' + ('(').join(word) + ')?' * len(word)
```

## 多系统路径分割方法

```py
import os
path = os.path.normpath(path)
path.split(os.sep)
```

## 遍历文件，返回列表

之前我用的都是`os.walk`，其实还有一种方式，使用`glob`

```py
import glob

for file in glob.iglob("{0}/*.yml".format(dirpath)):
    print(file)

# or

glob.glob("{0}/*.yml".format(dirpath))
```

## contextmanager 跳过代码块

- 参考[这篇文章](https://stackoverflow.com/questions/12594148/skipping-execution-of-with-block)

原型为

```py
import sys

class SkipWithBlock(Exception):
    pass


class SkipContextManager:
    def __init__(self, skip):
        self.skip = skip

    def __enter__(self):
        if self.skip:
            sys.settrace(lambda *args, **keys: None)
            frame = sys._getframe(1)
            frame.f_trace = self.trace

    def trace(self, frame, event, arg):
        raise SkipWithBlock()

    def __exit__(self, type, value, traceback):
        if type is None:
            return  # No exception
        if issubclass(type, SkipWithBlock):
            return True  # Suppress special SkipWithBlock exception


with SkipContextManager(skip=True):    
    print('In the with block')  # Won't be called
print('Out of the with block')
```

替换 contextmanager 的方法为:

```py
import sys
from contextlib import _GeneratorContextManager
from functools import wraps


class SkipWithBlock(Exception):
    pass


class _ContextManager(_GeneratorContextManager):
    def __enter__(self):
        del self.args, self.kwds, self.func
        try:
            return next(self.gen)
        except StopIteration:
            sys.settrace(lambda *args, **keys: None)
            frame = sys._getframe(1)
            frame.f_trace = self.trace

    def trace(self, frame, event, arg):
        raise SkipWithBlock()

    def __exit__(self, type, value, traceback):
        if type is None:
            try:
                next(self.gen)
            except StopIteration:
                return False
            else:
                raise RuntimeError("generator didn't stop")
        elif issubclass(type, SkipWithBlock):
            return True
        else:
            if value is None:
                value = type()
            try:
                self.gen.throw(type, value, traceback)
            except StopIteration as exc:
                return exc is not value
            except RuntimeError as exc:
                if exc is value:
                    return False
                if type is StopIteration and exc.__cause__ is value:
                    return False
                raise
            except:
                if sys.exc_info()[1] is value:
                    return False
                raise
            raise RuntimeError("generator didn't stop after throw()")


def contextmanager(func):
    """这个contextmanager可以在没有yield的时候，主动跳过代码块"""
    @wraps(func)
    def helper(*args, **kwds):
        return _ContextManager(func, args, kwds)

    return helper
```

## 单例类

用类继承会好些

```py
class Singleton(object):
  _instance = None
  def __new__(class_, *args, **kwargs):
    if not isinstance(class_._instance, class_):
        class_._instance = object.__new__(class_, *args, **kwargs)
    return class_._instance

class OtherClass(Singleton):
    ...
```