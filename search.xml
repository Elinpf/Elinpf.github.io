<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python 一劳永逸的 decode 字符串转换方法</title>
      <link href="/2021/07/12/python-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2/"/>
      <url>/2021/07/12/python-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="自动检测字符串类型并进行decode"><a href="#自动检测字符串类型并进行decode" class="headerlink" title="自动检测字符串类型并进行decode"></a>自动检测字符串类型并进行decode</h2><ul><li><a href="https://blog.csdn.net/jieli_/article/details/70166244">看这篇文章</a></li></ul><p>当不清楚字符串是什么类型的时候，比如html，此时可以使用<code>chardet</code>模块来进行识别</p><pre><code>import chardet   #需要导入这个模块，检测编码格式encode_type = chardet.detect(html)  html = html.decode(encode_type[&#39;encoding&#39;]) #进行相应解码，赋给原标识符（变量）从str到bytes:调用方法encode().编码是把Unicode字符串以各种方式编码成为机器能读懂的ASCII字符串从bytes到str:调用方法decode().</code></pre><h2 id="UnicodeDecodeError"><a href="#UnicodeDecodeError" class="headerlink" title="UnicodeDecodeError"></a>UnicodeDecodeError</h2><p>当出现<code>UnicodeDecodeError: &#39;gbk&#39; codec can&#39;t decode byte ...</code>，原因是文档中的特殊符号超过了gbk的字符集。</p><p>所以要么使用更广的<code>gb18030</code>要么忽略:</p><pre><code>open(path, encoding=&#39;gb18030&#39;)   # 更广的字符集open(path, encoding=&#39;gb18030&#39;, errors=&#39;ignore&#39;)   # 更广的字符集，并且错误的忽略</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> decode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相对论</title>
      <link href="/2021/07/06/%E7%9B%B8%E5%AF%B9%E8%AE%BA/"/>
      <url>/2021/07/06/%E7%9B%B8%E5%AF%B9%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="相对论的简单信念"><a href="#相对论的简单信念" class="headerlink" title="相对论的简单信念"></a>相对论的简单信念</h1><p>首先我们来讲一讲现代物理学的开始。<br>故事要从伽利略发现日心说开始，那时候的人都相信所有的星星都是绕着地球做运动的。但是伽利略看破了红尘，他明白了地球和其他行星都是绕着太阳做运动。而且并没有什么精灵在推着行星做运动，只需要太阳施加一个吸引力就可以。<br>第二个人是牛顿。<br>牛顿的第一定律描述了，在没有外力的作用下，物体会保持静止或者匀速直线运动。 匀速直线运动和静止一样无需外力。<br>牛顿的第二定律描述了，力会改变物体的运动方式。 请注意，这里说的是，力，是<strong>改变</strong>运动的原因。而不是力是运动的原因。<br>牛顿看破了红尘，在他的眼里，运动和静止是一回事。</p><p>第三个人是爱因斯坦。<br>看到了我们是相对于不同坐标系下来讨论这些问题的，这火车上，你射箭。相对于火车这个坐标系，你看到的是射箭的速度。 而相对于地面这个坐标系，那射箭的速度就是火车的速度加上射箭的速度。<br>可能有人会说，这不就是哲学上的参考不同的坐标系嘛，我们哲学家喝茶的功夫早就知道了。 但是爱因斯坦发现了让哲学家喝多少茶都想不到的事情。<br>当你在火车上打手电筒，手电筒的光的速度会不会是相对于地面的坐标系是光速加上火车的速度呢？<br>答案是不会，无论你从哪里去观察，光速都是一定的。天上和地下是一样的，我们这里和外星人那里也是一样的。<br>这是爱因斯坦的洞见，也是相对论和基础。</p><h1 id="电磁场英雄壮举"><a href="#电磁场英雄壮举" class="headerlink" title="电磁场英雄壮举"></a>电磁场英雄壮举</h1><p>英国物理学家詹姆斯。克拉克。麦克斯韦统一了电磁学。</p><p>当时的物理学好像有点杂乱无章，这时候麦克斯韦学众家之长，然后发现了电磁学。</p><p>首先我们弄清楚：<br>什么是电？电是电荷之间的相互作用。电子带负电，离子带正电。电子和离子产生吸引力。<br>什么是磁呢？ 磁来源于电，是电荷的运动产生了磁。 电流周围就会有磁。</p><p>什么是场？ 电荷与电荷之间没有什么<em>超距作用</em>，是电荷周会有场，电荷通过场来相互作用。<br>什么是电磁场？ 是电场和磁场相互叠加的一个总描述，叫做电磁场。</p><p>电可以生磁？变化的磁场产生电场， 反过来，变化的电场产生磁场。<strong>其中不需要电荷的存在</strong>。<br>这时，麦克斯韦想到，如果我用一个振荡器来产生周期变化的磁场，那么周期变化的磁场，就会产生电场。而周期变化的电场又会产生新的磁场，这么这样就可以一直传播下去。这就是<strong>电磁波</strong>。</p><p>电和磁的有规律的相互转化，产生了电磁波。<br>根据测量，电磁波的传播速度和光速一致。<br>麦克斯韦宣布，<strong>光其实就是电磁波</strong>。</p><blockquote><p>这是物理学家再一次看破了红尘。天上的东西和地上是一回事，匀速直线运动和静止是一回事，电和磁是一回事，而现在麦克斯韦说，光跟电磁场，其实也是一回事。</p></blockquote><p>但是，这里有一个问题，这个电磁波是根据什么坐标系来观测的？ 是发送电磁波的仪器吗？ 但是天文学家发现，双星系统，其中一个靠近我们，那另一个就是远离我们的情况下，观测到的两个行星的电磁波的速度其实是一样的。</p><p>当时的人们认为空间中存在<em>以太</em>这种物质来传播，但是被证明不存在。</p><p>此时爱因斯坦登场</p><blockquote><p>一般情况下师长们都告诉你要适应世界。爱因斯坦不是来适应世界的，他是来改变世界的。</p></blockquote><h1 id="刺激1905"><a href="#刺激1905" class="headerlink" title="刺激1905"></a>刺激1905</h1><p>这一年称为奇迹年，爱因斯坦发表了数篇论文，引发了人类关于物理世界的基本概念 – 时间、空间、能量、光和物质 – 的三大革命。</p><p>首先，爱因斯坦断言：</p><blockquote><p><strong>一切静止或者匀速直线运动的坐标系下，物理定律都一样。</strong></p></blockquote><p>这表明了不只有力在坐标系下都一样，而是所有物理定律 – 包括电动力学 – 都一样。</p><p>并且断言，<strong>光速无论是什么坐标系下，都一样。</strong><br>$$ c = 299,792,458 m/s $$</p><p>你所感觉的光速在火车上还是地上的速度问题，并不是光速的问题，而是你的时空观有问题。</p><p>现在假设你在火车上向天花板照一束光，是向下面这样的。</p><p><img src="/2021/07/06/%E7%9B%B8%E5%AF%B9%E8%AE%BA/relativity_1.jpg" alt="Alt text| center | 200*0"></p><p>而在地面上的人看到的结果是这样的：</p><p><img src="/2021/07/06/%E7%9B%B8%E5%AF%B9%E8%AE%BA/relativity_2.jpg" alt="Alt text | center | 500*0"></p><p>可以看出来，在地面坐标系种，光走的是斜线。<br>距离D比L要长，光速不变，所以时间更长。</p><p>结论是，在火车上你感觉到的时间要比在外面的时间短。<br><img src="/2021/07/06/%E7%9B%B8%E5%AF%B9%E8%AE%BA/relativity_3.png" alt="Alt text | left | 300*0"></p><p>$ v \uparrow \rightarrow \Delta t’ \uparrow$</p><p>速度越快， $\Delta t’ \uparrow $ 就越大在外面感受到的时间就越快。相对的，$\Delta t \downarrow$ 就越小，里面的人感受到的时间就越慢。<br>所以在地面坐标系下看，地上的人感受到的时间没有变化，而火车里的人的时间变慢了。<strong>是时间本身变慢了</strong></p><h1 id="穿越到未来"><a href="#穿越到未来" class="headerlink" title="穿越到未来"></a>穿越到未来</h1><h2 id="真的可以长寿"><a href="#真的可以长寿" class="headerlink" title="真的可以长寿"></a>真的可以长寿</h2><p>相对论的核心在于处于不用的坐标系来观察。</p><p>我们可以做这样的一个实验。<br>有一个星球距离我们80光年，我们通过加速到0.8c的宇宙飞船飞到那个星球。<br>在地面上的人看，这段时间需要花上100年。 而飞船上的宇航员自己则会感觉到只过去了60年。坐标系下的时间会发生<strong>时间膨胀</strong>。<br>要用这个方法来验证显然不太现实。但是物理学家想到了另外一种实验方法。</p><p>有一种叫做$\mu$子的基本粒子，他有一基本特性就是特别特别短命。 半衰期是2.2微秒。也就是说给你一堆$\mu$子，他们会在2.2微秒后只剩下一半了，然后再过2.2微秒又有一半木有了。<br>而这个实验就是将一堆$\mu$子从山顶上加速到0.9994c的光速，然后丢下来。如果到地面上的$\mu$子数量大于在静止坐标系下得到的数量，那么相对论就是正确的。</p><p>实验结果完美的符合了相对论的预测，平均寿命被延长了29.3倍！</p><p>相对论不但正确，而且非常精确。</p><h2 id="双生子佯谬"><a href="#双生子佯谬" class="headerlink" title="双生子佯谬"></a>双生子佯谬</h2><p>问题是这样的，你妹妹在地球上，而你坐上了宇宙飞船。<br>在妹妹的坐标系中，你处于高速运动中，你的时间变慢了。<br>而在你的坐标系中，妹妹同样也是高速离开，那妹妹的时间也变慢了。</p><p class='qst'>那你飞一圈回来后，是你比妹妹年轻还是妹妹比你年轻呢？<p class='asr'>这个问题的关键在于你的坐标系和你妹妹的坐标系并不是等价的。你所处于的运动过程，要有加速，匀速直线减速掉头再加速最后减速的过程。并不全都是匀速直线运动。计算的过程比较复杂，但是结论是真实的。并且你会比你妹妹年轻一些。<h2 id="时空是相对的"><a href="#时空是相对的" class="headerlink" title="时空是相对的"></a>时空是相对的</h2><p>和<strong>时间膨胀</strong>对应的是<strong>长度收缩</strong></p><p>当宇航员用20年的时间完成了本来需要30年才能完成的路程。那么相对于宇航员来看。这段路程实际上是变短了。</p><p>我们所处的坐标系下，其实和外星人所处的坐标系。在没有联系的情况下是完全两个独立的时空。你过你的，我过我的。但是一旦建立起了联系，那么就需要进行相对的转换了。</p><h1 id="“现在”是一个幻觉"><a href="#“现在”是一个幻觉" class="headerlink" title="“现在”是一个幻觉"></a>“现在”是一个幻觉</h1><h2 id="同时不同时"><a href="#同时不同时" class="headerlink" title="同时不同时"></a>同时不同时</h2><p>首先我们想象一个运动火车中中间的一盏灯，发出了一束光。<br>当你站在火车中的时候，这两束光是同时到达了火车头和火车尾部。<br><img src="/2021/07/06/%E7%9B%B8%E5%AF%B9%E8%AE%BA/relativity_5.jpg" alt="Alt text | center | 400*0"></p><p>而当你站在外面观察这盏灯发出来的光线。火车从左到右，那么这两束光线是先到达了车尾，后到达了车头。<br><img src="/2021/07/06/%E7%9B%B8%E5%AF%B9%E8%AE%BA/relativity_4.jpg" alt="Alt text | center | 400*0"></p><p>两个情况是不相同的。 同时还是不同时完全取决于你的坐标系。<br><strong>抛开坐标系谈相关性都是空谈。</strong></p><h2 id="光锥中的才是命运"><a href="#光锥中的才是命运" class="headerlink" title="光锥中的才是命运"></a>光锥中的才是命运</h2><p>事实上，我们身边发生的事情都不是同时发生的。<br><img src="/2021/07/06/%E7%9B%B8%E5%AF%B9%E8%AE%BA/relativity_6.jpg" alt="Alt text | center | 400*0"></p><p>这是时间的光锥。只有光锥内的事件才是会受到影响的事件。<br>过去的光锥中的事件可以影响观察者，而观察者也可以影响未来光锥中的事件。<br>但是光锥外的事件是无法影响观察这，并且观察者也无法影响光锥外的事件。</p><h1 id="质量就是能量"><a href="#质量就是能量" class="headerlink" title="质量就是能量"></a>质量就是能量</h1><h2 id="速度叠加"><a href="#速度叠加" class="headerlink" title="速度叠加"></a>速度叠加</h2><p>我们想象一下这样的场景，在火车上射出一支箭。火车的速度是$200m/s$，射出去的箭是$100m/s$。那么在外面的人来看。这个箭的速度应该是 $200 + 100 = 300m/s$ 。</p><p>那么是不是可以类推，在$0.8c$的飞船上，射出$0.5c$的火箭，那么就是 $0.8c + 0.5c = 1.3c$ 而超光速了呢？</p><p>爱因斯坦给出的答案是NO。因为<em>必须考虑到时间膨胀和长度收缩的效应。</em><br>其中$v$是飞船相对于地面的速度，$u’$是火箭相对于飞船的速度，$u$是火箭相对于地面的速度。<br>火箭相对于地面的速度并不是简单的$v + u’$ 。通过以下公式</p><p><img src="/2021/07/06/%E7%9B%B8%E5%AF%B9%E8%AE%BA/960631862.jpg" alt="Alt text | center | 200*0"></p><p>通过公式的出来的速度为$0.928c$，是没有超过光速的。<br><strong>如果$u’$ 和 $v$ 都远小于光速$c$的时候，那么这个公式就可以近似为$u = u’ + v$ 和我们生活定律一样。</strong></p><h2 id="质量变重"><a href="#质量变重" class="headerlink" title="质量变重"></a>质量变重</h2><p>现在来看另外一个例子</p><p>你在飞船上，我在地面上。飞船相对于地面有一个很高的速度。但是你坐在飞船里，飞船相对于你的速度为0。<br>你可以让飞船加速，你会产生推背感。并且一直保持有推背感，那么你是不是会觉得你速度越来越快，都快到达光速了呢。<br>但是在地面的我看来，你就想是个油腻的中年人，越走越慢。</p><p>就等效于你的质量越来越重，所以加速度越来越小。</p><ul><li>这就是相对论的另一个效应：<strong>高速运动物体的质量会变重</strong>。质量变重的形式和时间膨胀一样</li></ul><p><img src="/2021/07/06/%E7%9B%B8%E5%AF%B9%E8%AE%BA/52857151.jpg" alt="@m0是物体静止时候的质量 | center | 200*0"></p><p>可以从公式中看出来，当速度$v$越接近$c$，分母就越小。所得到的$m$就越大。</p><blockquote><p>相对论的几个效应可以用类比联想的方式记忆： <strong>运动会让你<em>更年轻</em>（时间膨胀）、<em>变瘦</em>（长度收缩），和<em>变结实</em>（质量变重）</strong> </p></blockquote><ul><li><strong>一切有质量的物体都不可能达到光速</strong></li><li>只有光子没有质量所以达到了光速。它不会变老，要么运动，要么消失。</li></ul><h2 id="E-mc-2"><a href="#E-mc-2" class="headerlink" title="$E = mc^2$"></a>$E = mc^2$</h2><p>那么现在又有一个问题了，这些增加出来的质量，是多在了哪里？</p><ul><li>爱因斯坦产生了这样的一个洞见： <strong>$mc^2$代表了一个物体的<em>全部能量</em> – 哪怕他静止不动，也有能量。</strong><br>这就是“质能方程”。</li><li><strong>物质和能量是一回事。</strong></li></ul><p>这就是狭义相对论</p><h1 id="广义相对论"><a href="#广义相对论" class="headerlink" title="广义相对论"></a>广义相对论</h1><h2 id="广义相对原理"><a href="#广义相对原理" class="headerlink" title="广义相对原理"></a>广义相对原理</h2><ul><li><strong>在所有坐标系下，物理定律都是一样的。</strong></li></ul><h2 id="加速度和引力"><a href="#加速度和引力" class="headerlink" title="加速度和引力"></a>加速度和引力</h2><p>我们可以想象一个这样的场景。<br>你处于一个一直做加速运动的火箭里。 你会感觉到一个力，这个力向下。此时你抛一个小球，这个小球也会朝着地面的方向掉落。那么这个实验和在地球上抛小球通过引力落回地面上有区别吗？</p><p><img src="/2021/07/06/%E7%9B%B8%E5%AF%B9%E8%AE%BA/1225873056.jpg" alt="Alt text | center | 300*0"></p><p>爱因斯坦说，<strong>我在火箭内部做实验，观测不到任何的区别</strong></p><h2 id="自由落体和匀速直线运动"><a href="#自由落体和匀速直线运动" class="headerlink" title="自由落体和匀速直线运动"></a>自由落体和匀速直线运动</h2><p class='qst'>自由落体是一个加速运动，但是为什么爱因斯坦说它跟匀速直线运动没有区别呢？<p class='asr'>**因为自由落体状态下物体的加速度都是一样的。**<p>我们知道，在地球上加速度G是一个恒定的数值$9.8m/s$<br>只有这样，两个质量不同的小球才会在同时下落的情况下同时到达地面。</p><ul><li><strong>在任何局部实验中，引力和加速度运动无法区分。</strong></li></ul><h2 id="广义相对论的结论"><a href="#广义相对论的结论" class="headerlink" title="广义相对论的结论"></a>广义相对论的结论</h2><ul><li>一个有质量的物质，会弯曲它周围的时空。这叫<em>“物质告诉时空如何弯曲”</em>。</li><li>在不受外力的情况下，一个物体总是沿着时空中的测地线运动。这叫<em>“时空告诉物质如何运动”</em>。 </li></ul><p>这里面不需要引力。</p>]]></content>
      
      
      <categories>
          
          <category> 科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>量子力学</title>
      <link href="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/"/>
      <url>/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>量子力学是描述微观粒子的物质行为的物理学理论，量子力学是我们理解除了万有引力之外的所有基本力的一个基础。这些基本力包括了电磁相互作用、强相互作用和弱相互作用。</p><p>量子力学主要是用来描述粒子在微观尺度下的行为，所有的粒子现象无法用经典力学精确描述。</p><p>为什么要了解一下量子力学？<br>我想，去了解一下这个世界上最聪明的那群人在思考些什么，这个事本身就非常有趣。</p><h1 id="量子力学的前夜"><a href="#量子力学的前夜" class="headerlink" title="量子力学的前夜"></a>量子力学的前夜</h1><p>在经典力学完备的情况下，19世纪末人们普遍认为经典物理已经非常完备了，只需要再解决两个小小的乌云就可以将物理学大厦封顶。后面的物理学家再修修补补一下就可以了。</p><p>但是，这两个小小的乌云却有点怪。</p><p>这两个乌云都与光有关，第一个是为什么光速再任何方向上都保持不变，这个直接导致了爱因斯坦发现了狭义相对论。<br>第二个是关于黑体辐射。</p><h2 id="紫外灾难"><a href="#紫外灾难" class="headerlink" title="紫外灾难"></a>紫外灾难</h2><p>紫外灾难是说，经典物理学解释黑体辐射问题与实验结果不符的历史事件。</p><p>黑体辐射问题，问的是黑体辐射强度与能量之间的关系。</p><blockquote><p>所谓黑体，就是物体不反射光，只会自身发光，比如太阳，烧红的烙铁</p></blockquote><p>实验物理学家给出了黑体辐射光频率的的分布曲线，但是这个曲线为什么是这样的，理论物理学家通过经典物理学无法解释。</p><p><img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/20210116123203.jpg"></p><p>这个时候，普朗克出来了，他通过纯数学凑数的办法，凑出了一个公式，而这个公式完美符合曲线。</p><p>但是这个公式怎么解释呢，最后发现，只要满足一个物理假设，就可以推导出这个公式，那就是要求每一个电子震动产生的无线电波的的能量不是连续的，而是<strong>一份一份</strong>的 。</p><p>$E = nhf$ 这里 n = 1, 2, 3 …<br>其中$f$是频率，$h$是常数，现在称为<strong>普朗克常数</strong>， h=6.626 * 10 ^(-34) 焦耳*秒。</p><p>这样就避免了紫外灾难。</p><p>但是普朗克并不清楚这<strong>一份一份</strong>意味着什么。</p><h2 id="光电效应"><a href="#光电效应" class="headerlink" title="光电效应"></a>光电效应</h2><p>光电效应是说光打到金属板上会由电子跑出来的现象。电子跑出来多少只与光是什么颜色的（频率）有关，而与这个光的强度无关。这个实验与经典力学是不符的，因为经典力学认为强度积攒多了也可以跑出电子来。</p><p>这时候爱因斯坦出来了，说这是因为光是一份一份的，普朗克不是说了么，光的一份能量是$E=hf$，频率越高能量越大，所以高频率的光的一份能量才足够大，才能打动电子。</p><p><em>可以打一个比方，拿石头去砸墙，光的频率就是石头的大小，你用大石头去砸墙就会有石膏掉落，但是用小石子却不会掉落。</em></p><p>这里的关键是爱因斯坦将普朗克的假说来了个思维跃迁，认为只要是光，能量就是一份一份的。</p><p>由紫外灾难引发了普朗克对黑体中电子受热震动的能量是一份一份的思考，然后由爱因斯坦提出了，<strong>光量子</strong>。</p><h2 id="什么是量子"><a href="#什么是量子" class="headerlink" title="什么是量子"></a>什么是量子</h2><p>普朗克与爱因斯坦的解题思路，叫做<strong>量子化</strong>，那么什么是量子呢。</p><p>比如高清电视，离得远了看非常丝滑，但是贴着看会有一个一个的晶体管，分辨率是有极限的，画面不是连续的，这个就是量子化。</p><p>那么为什么我们生活中感受不到世界是量子的呢，因为普朗克参数非常小，感觉不到。也就是分辨率太高了。</p><h1 id="经典量子力学"><a href="#经典量子力学" class="headerlink" title="经典量子力学"></a>经典量子力学</h1><h2 id="原子的内部结构"><a href="#原子的内部结构" class="headerlink" title="原子的内部结构"></a>原子的内部结构</h2><p>《庄子》中有句话：“一尺之棰，日取其半，万世不竭”，这句话在物理上是错的。</p><p>我们知道，分子是由原子组成的，原子是由原子核和电子组成的，原子核是由质子和中子组成的，质子和中子又是由夸克组成的。但是夸克是由什么组成的呢？ 现代物理学的标准模型认为，夸克和电子为<strong>基本粒子</strong>，是不可再分的。</p><p>就比如一本书，你可以分为章节，段落，句子，词，字，但是字就不可再分了，因为他们是抽象概念，无需再分。</p><p>而物质怎么分，正是量子力学的开始。</p><p>1896年，居里夫人发现铀原子能执法的往外发射某种射线，这个现象被称为”发射性“，并确定这个反应不是原子与原子之间发生的，而是由原子自身发出的，由此推断<strong>原子内部还有结构</strong></p><h2 id="波尔的原子模型"><a href="#波尔的原子模型" class="headerlink" title="波尔的原子模型"></a>波尔的原子模型</h2><p>1911年，汤姆生领导的一个研究小组发现了一种带着一个单位负电荷且质量极小的基本粒子并把它命名为电子。</p><p>卢瑟福和其学生通过金箔实验，物理学家认识到物质的内部几乎是真空的，原子核只占了原子很小的一部分。</p><blockquote><p>金箔实验：实验是用α粒子轰击各种金属箔纸，发现绝大多数α粒子的偏向很小，但少数的偏向角很大甚至大于90度。由此可以证明，一个原子大部分的体积是空的空间，这由没有被弹回的粒子充分说明。</p></blockquote><blockquote><p>这个实验推翻了约瑟夫·汤姆孙创建的汤姆孙模型 。根据这模型，原子是由电子悬浮于均匀分布的带正电物质里所组成。这个实验为建立现代原子核理论打下了坚实基础。</p></blockquote><p>卢瑟福的模型是电子围绕在原子核周围，但是现在由两个问题：</p><ol><li>电子是如何保持稳定轨道的？</li><li>原子的确会对外辐射，而不受干扰也会辐射，但是原子辐射的光谱很独特，不是连续的。</li></ol><p>接下来波尔登场。</p><p> 波尔想到了普朗克和爱因斯坦的解题思路，量子化。所以决定对电子的轨道量子化。并提出4个假设：</p><ol><li>电子平时按照特定的轨道运动，每个轨道由自己的能级，能级和“轨道量子数”成反比</li><li>电子在同一个轨道中运动时，并不向外辐射能量。</li><li>只有当电子在两个不同能级之间跃迁的时候，它才会辐射能量。</li><li>电子轨道有个角动量，角动量也要量子化。</li></ol><p>这个模型非常成功，光电效应不是说外来一个高能量的光子能把电子打飞么，需要多大的能量呢？答案是正好是那个电子所在能级的能量。</p><p>波尔还能明明白白地告诉你原子中如果有多少个电子，那么他们将如何排列，波尔等于解释了整个化学。</p><h2 id="波粒二象性"><a href="#波粒二象性" class="headerlink" title="波粒二象性"></a>波粒二象性</h2><p>什么东西即是波又是粒子，这就叫“波粒二象性”。我们仔细想想，这个东西会有什么样的行为。</p><p>如果电子是一个点，那么它如何展现”波动“的特性呢？它是不能走”之“字型路线的，因为会有急转弯，而导致加速运动，发生辐射，另外会超过光速，违反了相对论。</p><p>而如果电子是一片波动的云，那么我们为何每次都能捕捉到一个点的呢？从云到点的变化是如何发生的。</p><p>杨氏双缝实验，如果一个一个的发射电子，最后的出来的也会是干涉条纹。那么是谁与电子发生的干涉？是自己和自己吗？一个电子是如何同时通过了两个缝隙发生了自己与自己的干涉？</p><h1 id="现代量子力学的发展"><a href="#现代量子力学的发展" class="headerlink" title="现代量子力学的发展"></a>现代量子力学的发展</h1><h2 id="不确定性原理"><a href="#不确定性原理" class="headerlink" title="不确定性原理"></a>不确定性原理</h2><blockquote><p>海森堡解释了不确定性原理。当时的他并没有意识到，这个原理即代表了物理学的探索边界，又是量子世界最核心的规则。</p></blockquote><p>海森堡说，电子有时候表现的像粒子，有时候又表现的像个波，那么它到底是什么，这个我们无法想象，也没有必要想象。</p><p>应该关心的是<strong>可测量</strong>的东西，电子的轨道其实是不可测量的。</p><p>如果想要得到电子的路线图，那么需要同时知道电子的位置和速度（也就是动量$p=mv$），但是，海森堡说，这个是不可能的，你无法同时精确的知道电子的位置和动量。</p><p><strong>位置的测量误差和动量的测量误差是一个取舍关系，他们不可能都很小</strong></p><p>这个解释很有道理，但是还不够彻底，还不够革命。</p><p>海森堡说的是测不准，说的是你的测量手段本身相悖。因为想测量一个东西就不得不干扰这个东西。但是并不是这样的。</p><p>量子力学正在的观点不是<strong>测不准</strong>，而是<strong>不确定</strong>。不是你能力的问题，而是电子的本性问题。</p><p>电子根本不能同时拥有确定的位置和动量。电子的行为有内在的不确定，永远都是模糊的。</p><p>这个原理就是<strong>海森堡不确定性原理</strong>。</p><p>下面这个图才是原子的样子。</p><p><img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/95b07a231f127e8656732a1396fab30.png" alt="Alt text | center | 300*0"></p><p>电子并不是绕着原子核做圆周运动，电子没有确定的位置，它同时出现在原子核之外的各个地方，呈现出来的是的是一片”云“，其实原子核也是一片”云“。</p><p><strong>”不确定“是量子世界的本质，海森堡要求我们专注于那些能测量的东西，坦然接受测量结果的不确定性。</strong></p><p>直到今天，我们也只是知道电子的一些”性质“，但是电子到底是个什么东西，我们并不知道。</p><h2 id="薛定谔的波动方程"><a href="#薛定谔的波动方程" class="headerlink" title="薛定谔的波动方程"></a>薛定谔的波动方程</h2><p><img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/ebb011724d8c83747d5703f4412b942.png" alt="Alt text"></p><p>这个方程描述了<strong>波函数</strong> $ψ(x,t)$ 在不同位置和时间的变化。</p><p>有了薛定谔的方程，我们就可以精确的知道波函数在任何时间位置的数值。</p><p>但是波函数到底指的是什么，这时候的薛定谔并不清楚。后来德国物理学家马克斯·玻恩提出了解释</p><blockquote><p>波函数绝对值的平方，等于粒子出现在那个时间和那个地点的概率</p></blockquote><p>没有被观测的粒子就好像是一片与，它既可以在这里也可以在那里，但是它出现的概率是不一样的，如果是0就绝对不可能出现。</p><p>但是这里有两个问题：</p><ol><li>玻恩解释说明量子力学是一个关于概率的科学。</li><li>波函数是一个十分怪异的存在。</li></ol><p>为什么怪异？ 当电子打到屏幕上，位置固定下来以后，波函数瞬间就在其他位置都变成了0。这叫<strong>波函数的坍缩</strong>。电子从一个”波“坍缩成了”粒子“。那么这个过程中发生了什么呢？</p><p>本来是全局的，坍缩后突然变成了一个点。这个过程是不连续的，是不可逆的。</p><h2 id="量子隧穿"><a href="#量子隧穿" class="headerlink" title="量子隧穿"></a>量子隧穿</h2><p>在经典力学中，小球是不可能凭空穿过一面墙的。但是在微观的量子世界中，穿过墙壁只是一个概率问题。</p><p><img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/8588f9399d49ecaebaa74b9af313276.png" alt="Alt text | center"></p><p>图中的E是粒子的能量，而V是墙的势能。 墙的势能V比粒子的能量E高，所以墙对粒子造成了限制。</p><p>波函数在经过墙迅速衰减，虽然波动幅度小了，但并不是一条直线，所以根据玻恩解释，粒子是可以到达墙后面的。</p><p>能量小的粒子穿过了势能大的物质，就叫做<strong>量子隧穿</strong>。</p><p>量子隧穿在很多方面都有应用和体现：</p><ol><li><p>质子和中子的动能比结合力的势能小，但是他们能跑出来，这就造成了发射性原子核衰变。这是量子隧穿的功劳。</p></li><li><p>核聚变要求原子核与原子核克服库仑位势垒，单独的热能无法达到以促成核聚变。但是量子隧穿能够突破，才有了核聚变，才有了太阳。</p></li><li><p>DNA的自发性突变，质子隧穿透过了DNA的碱基对的氢键位势垒，使得DNA复制中发生突变，这才有了丰富多样的世界。</p></li></ol><h2 id="狄拉克引领的量子电动力学"><a href="#狄拉克引领的量子电动力学" class="headerlink" title="狄拉克引领的量子电动力学"></a>狄拉克引领的量子电动力学</h2><p>保罗·狄拉克融合了狭义相对论的波动方程叫做<strong>狄拉克方程</strong>，这个方程解出了两个新东西：</p><ol><li>有正电子， 这个是人类发现的第一个反物质</li><li><strong>自旋</strong></li></ol><p class='quest'>什么是自旋？<p class='answer'>电子绕着原子核做旋转之外，自身还有一个旋转，这个自身旋转的角动量是“量子化”的，也就是说它的角动量只有“1/2”和“-1/2”两个值，我们把电子的自身旋转称为自旋。<p>但是，请注意，这里的自旋是无法形象的理解的。电子的自旋为1/2，那么把电子想象成小球的话，这个小球必须转两圈才能回到原来的样子。并且根据自旋角动量的计算，这个小球的表面速度已经超过了光速，这个不合理。</p><p>另外需要注意的是，到目前为止，物理学家对电子的理解只是知道了它的各种内在属性，但是电子到底是什么我们并不清楚。</p><p>所以，<strong>自旋是电子的一个内在属性，是一个具有角动量特点的性质</strong></p><p>将电子自旋的状态标示，可以写成<br><img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/3ccc9de8992d16efc2275924a9c7259.png" alt="Alt text| center | 300*0"></p><p>狄拉克发明的“半个括号” （”**|&gt;<strong>“）表示了一个量子态，所以这个公式说的是电子的量子态是自旋方向上的两个正负量子态之和。这个就是“</strong>量子叠加态**”</p><p>电子的自旋描述的是一个方向上的电子的自旋的量子态，在另外一个方向上，有着另一个，完全不相干的自旋量子态。</p><p>比如说我们是在x方向上观察电子的量子态，可以得到<img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/11af993e137cc9196dd1475e562ddc9.png" alt="Alt text | 200*0"><br>同样我们观测z方向上的电子的自旋量子态，可以得到<img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/c34780b706571ea14ca0b34a798c5cd.png" alt="Alt text | 200*0"><br>这两个方向上的量子叠加态是互不相干的。</p><ul><li>现在我们更进一步：</li></ul><p>在我们观察z方向正1/2自旋电子后的，继续对这个电子进行x方向的观测，那么它同样会有x方向的叠加态<img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/aa96b3e5b76f2c313615001349d9fd6.png" alt="Alt text|200*0"></p><p>更进一步，如果继续在x方向对观测到的x方向的坍缩的电子进行观测，那么它保持原来的自旋态性质不变。</p><p>他的过程是下面这样的：<br><img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/aae536a7b0c30cb3717847ba22dffcf.png" alt="Alt text| center | 700*0"></p><p>这样的性质被<strong>冯·诺依曼投影公设</strong>解释：</p><ol><li>每个量子态，都可以展开成一系列基本的量子态的叠加  <img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/fa666bc9763be81afa3be6deb4b701c.png" alt="Alt text| 200*0"></li><li>一次实验观测后，系统就坍缩到其中的一个态e_i。而到底坍缩到哪个态，由系数c_i的绝对值的平方决定。</li><li>从此以后，系统就一直处于e_i态。但如果e_i态还有不确定性，系统就可以再次被观测到别的态，方法仍然使用量子态叠加展开。</li></ol><p>那么哪部分是属于量子电动力学的呢？<br>这么说吧。引力，属于广义相对论的范畴，原子核以内的属于更现代物理理论。不考虑引力，在原子核之外的所有的万事万物都归量子电动力学管</p><h2 id="泡利不相容原理"><a href="#泡利不相容原理" class="headerlink" title="泡利不相容原理"></a>泡利不相容原理</h2><p><img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/85e27b3308331e0c1f638db77af2f2f.png" alt="Alt text | center | 500*0"></p><p>上图是电子云图，颜色的深浅代表了电子在一个地方被发现的概率。</p><p>完全确定电子的状态，需要4个“量子数”。</p><ol><li>主量子数<code>n</code>， 代表电子所处的能级，能级越高，电子出现在那里的概率越低。</li><li>角动量量子数 <code>l</code>,代表电子轨道的形状，也就是电子云的形状，l=0为球形，l越大，电子云越扁。</li><li>磁量子数<code>m</code>, 代表轨道的方向。</li><li>自旋量子数。</li></ol><p>泡利不相容原理说，<strong>一个原子的任何两个电子的是个量子数，不能完全相同。</strong></p><p>正因为有了泡利不相容原理，才能让电子不会全部集中在低能级上。大原子的势力范围才更大，才能有外层电子决定各种化学性质。世界才如此多姿多彩。</p><p>为什么电子会遵守泡利不相容原理呢？根本原因是自旋的数学。</p><p>所有的基本粒子分为两类：</p><ol><li><strong>玻色子</strong>， 它们的自旋是整数，它们是力的传播者，像胶子、介子、希格斯粒子和想象中的引力子都是玻色子。光子也是玻色子，自旋是1</li><li><strong>费米子</strong>， 它们的自旋是半整数，也就是±1/2、±3/2、±5/2这样，费米子是力的感受者。像电子、质子、中子都是费米子。</li></ol><p>在数学上，玻色子的波函数具有交换对称性，而费米子的波函数具有反交换对称性。两个全同费米子的波函数一定是交换对称的，而对称的中心点必须是0，而0代表了所有量子数都相同，所以量子数不能完全相同。</p><blockquote><p>简单的来说<br>之所以有化学，是因为泡利不相容原理；<br>之所以有泡利不相容原理，是因为费米子波函数是反对称的。<br>之所以费米子波函数是反对称的，是因为自旋；<br>之所以有自旋，是因为量子电动力学；<br><strong>设定了量子电动力学，就设定了原子核以外的世界</strong></p></blockquote><h2 id="全同粒子"><a href="#全同粒子" class="headerlink" title="全同粒子"></a>全同粒子</h2><p>在量子的微观世界，你是不能区分两个粒子的区别的，电子与电子，质子与质子，他们完全相同，没有任何区别，甚至连位置信息，因为薛定谔不确定性原理，你也不能通过位置来却别粒子。</p><h2 id="哥本哈根诠释"><a href="#哥本哈根诠释" class="headerlink" title="哥本哈根诠释"></a>哥本哈根诠释</h2><p>哥本哈根诠释并不是一套物理定律，而是一套物理研究方法和哲学立场</p><ol><li>量子力学只是关于测量结果的科学，它并不研究测量结果背后的”真相“到底是什么。</li><li>波函数只是一个描写概率的数学形式，而不是一个物理实在。</li><li>既然波函数根本不是物理实在，那么也就谈不上”坍缩“，所谓的坍缩也就是测量前后的数学信息变化而已。</li><li>波函数就是我们所能知道的全部信息。</li><li>为什么日常生活中的东西没有表现出量子力学的效应？因为宏观是众多粒子的集体行为。</li></ol><h2 id="爱因斯坦的最后一战"><a href="#爱因斯坦的最后一战" class="headerlink" title="爱因斯坦的最后一战"></a>爱因斯坦的最后一战</h2><p>1935年，爱因斯坦对量子力学发出最后一击。是一个思想实验，人们称为”EPR佯谬“。</p><p>这个思想实验是这样的：</p><blockquote><p>A和B两个全同粒子，它们本来是在一起的，然后因为原子核衰变分开了，然后它们沿着直线各自往相反的方向飞行。<br>根据动量守恒，A和B的动量必定是互为相反数，而且A走多远，B也一定走多远。<br>那么我只要测量一下A的位置是x，就知道了B的位置是-x。<br>我再测量B的动量是-p，那么A的动量就是-p<br>这样的话我就只对一个粒子测量了一次，但是却同时知道了它的位置和动量，违反了海森堡不确定性原理。</p></blockquote><p>爱因斯坦这个思想实验的所有测量都是合法的，没有犯任何错误。波尔阵营对此只能给出一个反驳：</p><p>A和B两个粒子应该被视为同一个量子系统，用一个波函数来描写。当测量A位置的时候，就相当于测了B的位置，从而破坏了B的动量。</p><p>这一次爱因斯坦没有接受，说，我这两个粒子可以距离几光年远再测量，如果测量A的同时就破坏了B的动量，这难道不是<strong>鬼魅般的超距作用</strong>吗？</p><p>对此波尔无言以对，波尔的唯一合理反驳就是量子系统真的有鬼魅般的超距作用。</p><p><strong>鬼魅般的超距作用，从此成为了量子力学的命门</strong></p><h2 id="鬼魅般的超距作用"><a href="#鬼魅般的超距作用" class="headerlink" title="鬼魅般的超距作用"></a>鬼魅般的超距作用</h2><p>贝尔在1964年提出了可证伪的实验理论设想：其中的关键结论是测量两端的结果满足”4% &gt; 1% + 1%“这样的不等式，如果满足，那么波尔是对的；不满足，爱因斯坦是对的。</p><p><img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/f6cfe3f7150c3746d309dfeecff898b.jpg" alt="Alt text| center| 300*0"><br><img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/59ea0217eeb68158caf0617fbe892bf.jpg" alt="Alt text | center | 300*0"></p><p>最后实验证明，波尔是正确的，真的有鬼魅般的超距作用，是两个粒子之间发生的协调，这就是<strong>量子纠缠</strong>。</p><ol><li>粒子的某个属性，比如自旋，是在被观测的那一刹那才确定下来的。而不是提前设置好的。</li><li>量子纠缠是发生在两个粒子之间的。</li><li>量子纠缠虽然是真的，但是不能用来传递信息。</li></ol><h2 id="波函数的空间感知超能力"><a href="#波函数的空间感知超能力" class="headerlink" title="波函数的空间感知超能力"></a>波函数的空间感知超能力</h2><p>有这么一个实验，实验装置如下：</p><p><img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/543f5e38435fbbe4689bf1d44d992d8.jpg" alt="Alt text | center | 500 *0"></p><p>用波的视角来看光，最后只会在探测器2上接受到光，因为波的干涉原理，这里是经典物理学范畴。</p><p>现在以粒子的视角来看看，每次只发射一个光子，那么会出现情况呢？<br>光子每一次通过分束器都有一半的概率被反射或者透过。那么是不是说探测器1就有一半的几率接受到这个光子？</p><p>答案是不对，这是因为光子会<strong>同时</strong>走过两条路径，在分束器2的时候，光子会自己与自己发生干涉，抵消掉去往探测器1的光子。实验结果与经典物理学一样。 这是怎么回事呢？</p><blockquote><p>光子在出发前的那一刹那，它的波函数，就对所有的路径、干涉仪全局的设置，有一个总体感知。是这个”<strong>总体感知</strong>“告诉光子应该如何运动。<br>也就是说光子即走了路径1，也走了路径2，这个光子处于两条路径的“量子叠加态”。</p></blockquote><p>第二个实验是探测炸弹实验，问如何用光学的方法探测是否有炸弹。这个炸弹无比敏感，对一个光子就会发生爆炸。</p><p><img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/01177690293872659e441e2be78b309.jpg" alt="Alt text | center | 500*0"></p><p>通过实验可以发现，有1/4的概率，探测器1会收到光子。那么只要4次里面有一次在探测器1上收到了光子，那么炸弹一定存在。（真实实验中，可以通过微调，将概率无限接近于1）</p><p>为什么会在探测器1上收到光子呢？因为光子在出发的一瞬间就知道路径2被阻断了，无法与自己干涉，所以在会出现在探测器1上。也就事说光子在去到分束器1的时候，就发生了坍缩，而导致只有路径1可以被选择。</p><p>这样，就做到了经典物理中无论如何也无法完成的探测炸弹的事。<strong>量子力学可以传递出经典物理禁止传递的信息</strong>。</p><blockquote><p>光子要有粒子性，波函数要有感知能力，这两个条件加起来才叫做量子力学。</p></blockquote><h2 id="波函数的时间感知能力"><a href="#波函数的时间感知能力" class="headerlink" title="波函数的时间感知能力"></a>波函数的时间感知能力</h2><p>有这么一个实验，实验装置如下：</p><p><img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/ec47544409c42535bb276ed24b0738d.jpg" alt="Alt text| center | 500*0"></p><p>D1 和 D2 是测量光子粒子性的观测器，而可移动的屏幕可以理解为测量光子波动性的观测器。当用可移动的屏幕挡住D1和D2的时候，光子表现出来的是波的特性，有干涉条纹。而拿掉屏幕，用D1和D2作为观测的时候，不会发生干涉，会接收到每一个光子，表现出来的是粒子性。</p><p><img src="/2021/07/06/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/b13faead4f0ba2aa96fe072d215ee51.png" alt="Alt text | center | 500*0"></p><p>也就是说，你想测量光子的波动性，那么光子就会表现出波的特性。如果你想测量光子的粒子性，那么光子就会表现出粒子性。<strong>光子是表现波还是粒子，取决于你问他什么问题</strong></p><ul><li><strong>惠勒的延迟选择</strong></li></ul><p>现在进一步实验，当我们在光子通过双缝之后，再决定是观察什么，那么光子会表现出来什么性质呢？<br>答案是，还是会表现出想要观测的性质。这意味着我们现在的选择，改变了过去的事件。</p><p><strong>量子纠缠实验证明波函数有超越时空的感知能力，延迟选择实验证明波函数有超越时间的感知能力</strong></p><p>但请注意，这种超越时间的感知能力只能影响，不能控制波函数，所以没有违反相对论。</p><p class='quest'>光子在测量前的一瞬间改变了性质，那会不会是它同时处于粒子与波的叠加态，然后测量的时候坍缩了呢？<p class='answer'>并不是，如果想要表现波的一面，那么就必须了解两条路径，积累到相应的相位差，才能正好形成干涉；而如果想要表现出粒子性，就必须真的走过一个缝，才能形成有缝的统计结果。它必须记得路上的情况才行。关键不在于它最后的坍缩的表现，而是他如何知道路径上的信息，它是如何过来的。]]></content>
      
      
      <categories>
          
          <category> 科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell 速查表</title>
      <link href="/2021/07/06/shell-%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
      <url>/2021/07/06/shell-%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><pre><code>#!/bin/bashmsg=&quot;hello world&quot;echo $msg</code></pre><p><strong>变量名的命名须遵循如下规则：</strong></p><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li></ul><h1 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h1><pre><code>#!/bin/bashecho &quot;执行的文件名：$0&quot;;echo &quot;第一个参数为：$1&quot;;echo &quot;第二个参数为：$2&quot;;echo &quot;第三个参数为：$3&quot;;</code></pre><p><strong>脚本内获取参数的格式为：</strong></p><p>$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……</p><p><strong>另外，还有几个特殊字符用来处理参数：</strong></p><table><thead><tr><th align="center">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center"><code>$#</code></td><td align="left">传递到脚本的参数个数</td></tr><tr><td align="center"><code>$*</code></td><td align="left">以一个单字符串显示所有向脚本传递的参数。如”$*”用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。</td></tr><tr><td align="center"><code>$$</code></td><td align="left">脚本运行的当前进程ID号</td></tr><tr><td align="center"><code>$!</code></td><td align="left">后台运行的最后一个进程的ID号</td></tr><tr><td align="center"><code>$@</code></td><td align="left">与<code>$*</code>相同，但是使用时加引号，并在引号中返回每个参数。如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。</td></tr><tr><td align="center"><code>$-</code></td><td align="left">显示Shell使用的当前选项，与set命令功能相同。</td></tr><tr><td align="center"><code>$?</code></td><td align="left">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr></tbody></table><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><pre><code>#!/bin/bashmy_array=(A B &quot;C&quot; D)echo &quot;第一个元素为: $&#123;my_array[0]&#125;&quot;echo &quot;第二个元素为: $&#123;my_array[1]&#125;&quot;echo &quot;第三个元素为: $&#123;my_array[2]&#125;&quot;echo &quot;第四个元素为: $&#123;my_array[3]&#125;&quot;echo &quot;数组的元素为: $&#123;my_array[*]&#125;&quot;echo &quot;数组的元素为: $&#123;my_array[@]&#125;&quot;echo &quot;数组元素个数为: $&#123;#my_array[*]&#125;&quot;echo &quot;数组元素个数为: $&#123;#my_array[@]&#125;&quot;</code></pre><h1 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h1><blockquote><p>原生 bash 不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p></blockquote><p>expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</p><h2 id="1-算数运算符"><a href="#1-算数运算符" class="headerlink" title="1. 算数运算符"></a>1. 算数运算符</h2><pre><code>#!/bin/bashecho &quot;2加2等于&quot;`expr 2 + 2`echo &quot;2减2等于&quot;`expr 2 - 2`echo &quot;2乘2等于&quot;`expr 2 \* 2`echo &quot;2除2等于&quot;`expr 2 / 2`echo &quot;2除2取余&quot;`expr 2 % 2`</code></pre><h2 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2. 关系运算符"></a>2. 关系运算符</h2><pre><code>#!/bin/basha=10b=20if [ $a -eq $b ] # 检测两个数是否相等，相等返回 true。if [ $a -ne $b ] # 检测两个数是否不相等，不相等返回 true。if [ $a -gt $b ] # 检测左边的数是否大于右边的，如果是，则返回 true。if [ $a -lt $b ] # 检测左边的数是否小于右边的，如果是，则返回 true。if [ $a -ge $b ] # 检测左边的数是否大于等于右边的，如果是，则返回 true。if [ $a -le $b ] # 检测左边的数是否小于等于右边的，如果是，则返回 true。</code></pre><h2 id="3-布尔运算符"><a href="#3-布尔运算符" class="headerlink" title="3. 布尔运算符"></a>3. 布尔运算符</h2><pre><code>#!/bin/bashif [ ! false ]       # 非运算，返回 trueif [ true -o false ] # 或运算，返回 trueif [ true -a false ] # 与运算，返回 false</code></pre><h2 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4. 逻辑运算符"></a>4. 逻辑运算符</h2><pre><code>#!/bin/basha=10b=20if [[ $a -lt $b &amp;&amp; $a -gt $b ]]   # 逻辑的 AND, 返回 falseif [ $a -lt $b ] &amp;&amp; [ $a -gt $b ] # 逻辑的 AND, 返回 falseif [[ $a -lt $b || $a -gt $b ]]   # 逻辑的 OR, 返回 trueif [ $a -lt $b ] || [ $a -gt $b ] # 逻辑的 OR, 返回 true</code></pre><h2 id="5-字符串运算符"><a href="#5-字符串运算符" class="headerlink" title="5. 字符串运算符"></a>5. 字符串运算符</h2><pre><code>#!/bin/basha=&quot;abc&quot;b=&quot;efg&quot;if [ $a = $b ]   # 检测两个字符串是否相等，相等返回 true。if [ $a != $b ]  # 检测两个字符串是否相等，不相等返回 true。if [ -z $a ]     # 检测字符串长度是否为0，为0返回 true。if [ -n &quot;$a&quot; ]   # 检测字符串长度是否为0，不为0返回 true。if [ $a ]        # 检测字符串是否为空，不为空返回 true。</code></pre><h2 id="6-文件测试运算符"><a href="#6-文件测试运算符" class="headerlink" title="6. 文件测试运算符"></a>6. 文件测试运算符</h2><p>文件测试运算符用于检测 Unix 文件的各种属性。</p><table><thead><tr><th align="center">操作符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">-b file</td><td align="left">检测文件是否是块设备文件，如果是，则返回 true。</td></tr><tr><td align="center">-c file</td><td align="left">检测文件是否是字符设备文件，如果是，则返回 true。</td></tr><tr><td align="center">-d file</td><td align="left">检测文件是否是目录，如果是，则返回 true。</td></tr><tr><td align="center">-f file</td><td align="left">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td></tr><tr><td align="center">-g file</td><td align="left">检测文件是否设置了 SGID 位，如果是，则返回 true。</td></tr><tr><td align="center">-k file</td><td align="left">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td></tr><tr><td align="center">-p file</td><td align="left">检测文件是否是有名管道，如果是，则返回 true。</td></tr><tr><td align="center">-u file</td><td align="left">检测文件是否设置了 SUID 位，如果是，则返回 true。</td></tr><tr><td align="center">-r file</td><td align="left">检测文件是否可读，如果是，则返回 true。</td></tr><tr><td align="center">-w file</td><td align="left">检测文件是否可写，如果是，则返回 true。</td></tr><tr><td align="center">-x file</td><td align="left">检测文件是否可执行，如果是，则返回 true。</td></tr><tr><td align="center">-s file</td><td align="left">检测文件是否为空（文件大小是否大于0），不为空返回 true。</td></tr><tr><td align="center">-e file</td><td align="left">检测文件（包括目录）是否存在，如果是，则返回 true。</td></tr></tbody></table><h1 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h1><h2 id="1-命令格式"><a href="#1-命令格式" class="headerlink" title="1. 命令格式"></a>1. 命令格式</h2><pre><code>#!/bin/bashecho &quot;It is a test&quot;echo It is a testecho &quot;\&quot;It is a test\&quot;&quot;      # 转义name=Chrisecho &quot;$name is handsome&quot;echo -e &quot;OK! \n&quot;             # 显示换行 -e 开启转义echo &quot;It is a test&quot; &gt; myfile # 显示结果定向至文件echo &#39;$name\&quot;&#39;               # 原样输入字符串，不进行转义或取变量（使用单引号）echo `date`                  # 显示命令执行结构</code></pre><h2 id="2-颜色显示"><a href="#2-颜色显示" class="headerlink" title="2. 颜色显示"></a>2. 颜色显示</h2><pre><code>echo -e &quot;\033[字背景颜色；文字颜色m字符串\033[0m&quot;echo -e “\033[30m 黑色字 \033[0m”echo -e “\033[31m 红色字 \033[0m”echo -e “\033[32m 绿色字 \033[0m”echo -e “\033[33m 黄色字 \033[0m”echo -e “\033[34m 蓝色字 \033[0m”echo -e “\033[35m 紫色字 \033[0m”echo -e “\033[36m 天蓝字 \033[0m”echo -e “\033[37m 白色字 \033[0m”echo -e “\033[40;37m 黑底白字 \033[0m”echo -e “\033[41;37m 红底白字 \033[0m”echo -e “\033[42;37m 绿底白字 \033[0m”echo -e “\033[43;37m 黄底白字 \033[0m”echo -e “\033[44;37m 蓝底白字 \033[0m”echo -e “\033[45;37m 紫底白字 \033[0m”echo -e “\033[46;37m 天蓝底白字 \033[0m”echo -e “\033[47;30m 白底黑字 \033[0m”\33[0m 关闭所有属性\33[1m 设置高亮度\33[4m 下划线\33[5m 闪烁\33[7m 反显\33[8m 消隐\33[30m — \33[37m 设置前景色\33[40m — \33[47m 设置背景色\33[nA 光标上移n行\33[nB 光标下移n行\33[nC 光标右移n行\33[nD 光标左移n行\33[y;xH设置光标位置\33[2J 清屏\33[K 清除从光标到行尾的内容\33[s 保存光标位置\33[u 恢复光标位置\33[?25l 隐藏光标\33[?25h 显示光标</code></pre><h1 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a>sprintf</h1><pre><code>#!/bin/bashprintf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kg  printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876</code></pre><p>结果：</p><pre><code>姓名     性别   体重kg郭靖     男      66.12杨过     男      48.65郭芙     女      47.99</code></pre><blockquote><p><code>%s %c %d %f</code> 都是格式替代符<br><code>d</code>: Decimal 十进制整数 – 对应位置参数必须是十进制整数，否则报错！<br><code>s</code>: String 字符串 – 对应位置参数必须是字符串或者字符型，否则报错！<br><code>c</code>: Char 字符 – 对应位置参数必须是字符串或者字符型，否则报错！<br><code>f</code>: Float 浮点 – 对应位置参数必须是数字型，否则报错！<br><code>%-10s</code> 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐）,任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。<br><code>%-4.2f</code> 指格式化为小数，其中.2指保留2位小数。</p></blockquote><h1 id="test"><a href="#test" class="headerlink" title="test"></a>test</h1><p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p><pre><code>#!/bin/bashnum1=100num2=100if test $[num1] -eq $[num2]</code></pre><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="1-if-else"><a href="#1-if-else" class="headerlink" title="1. if-else"></a>1. if-else</h2><pre><code>#!/bin/basha=10b=20if [ $a == $b ]then   echo &quot;a 等于 b&quot;elif [ $a -gt $b ]then   echo &quot;a 大于 b&quot;elif [ $a -lt $b ]then   echo &quot;a 小于 b&quot;else   echo &quot;没有符合的条件&quot;fi</code></pre><h2 id="2-for"><a href="#2-for" class="headerlink" title="2. for"></a>2. for</h2><pre><code>#!/bin/bashfor loop in 1 2 3 4 5do    echo &quot;The value is: $loop&quot;done</code></pre><h2 id="3-while"><a href="#3-while" class="headerlink" title="3. while"></a>3. while</h2><pre><code>#!/bin/bashint=1while(( $int&lt;=5 ))do    echo $int    let &quot;int++&quot;done</code></pre><h2 id="4-case"><a href="#4-case" class="headerlink" title="4. case"></a>4. case</h2><pre><code>#!/bin/bashecho &#39;输入 1 到 4 之间的数字:&#39;echo &#39;你输入的数字为:&#39;read aNumcase $aNum in    1)  echo &#39;你选择了 1&#39;    ;;    2)  echo &#39;你选择了 2&#39;    ;;    3)  echo &#39;你选择了 3&#39;    ;;    4)  echo &#39;你选择了 4&#39;    ;;    *)  echo &#39;你没有输入 1 到 4 之间的数字&#39;    ;;esac</code></pre><h2 id="5-break"><a href="#5-break" class="headerlink" title="5. break"></a>5. break</h2><p>break命令允许跳出所有循环（终止执行后面的所有循环）。</p><pre><code>#!/bin/bashwhile :do    echo -n &quot;输入 1 到 5 之间的数字:&quot;    read aNum    case $aNum in        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;        ;;        *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot;            break        ;;    esacdone</code></pre><h2 id="6-continue"><a href="#6-continue" class="headerlink" title="6. continue"></a>6. continue</h2><p>跳出当前循环。</p><pre><code>#!/bin/bashwhile :do    echo -n &quot;输入 1 到 5 之间的数字: &quot;    read aNum    case $aNum in        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;        ;;        *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot;            continue            echo &quot;游戏结束&quot;        ;;    esacdone</code></pre><h2 id="7-until"><a href="#7-until" class="headerlink" title="7. until"></a>7. until</h2><pre><code>#!/bin/basha=0until [ ! $a -lt 10 ]do   echo $a   a=`expr $a + 1`done</code></pre><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><pre><code>#!/bin/bashfunWithParam()&#123;    echo &quot;第一个参数为 $1 !&quot;    echo &quot;第二个参数为 $2 !&quot;    echo &quot;第十个参数为 $10 !&quot;    echo &quot;第十个参数为 $&#123;10&#125; !&quot;    echo &quot;第十一个参数为 $&#123;11&#125; !&quot;    echo &quot;参数总数有 $# 个!&quot;    echo &quot;作为一个字符串输出所有参数 $* !&quot;&#125;funWithParam 1 2 3 4 5 6 7 8 9 34 73</code></pre><p>结果： </p><pre><code>第一个参数为 1 !第二个参数为 2 !第十个参数为 10 !第十个参数为 34 !第十一个参数为 73 !参数总数有 11 个!作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !</code></pre><h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><pre><code>#!/bin/bashwho &gt; today.log # 执行结果覆盖到文件 today.logecho &quot;菜鸟教程：www.runoob.com&quot; &gt;&gt; today.log # 执行结果追加到文件 today.logwc -l &lt; today.log # 统计 today.log 行数wc -l &lt;&lt; EOF    李白    苏轼    王勃EOF</code></pre><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><p>test1.sh</p><pre><code>#!/bin/bashname=&quot;Chris&quot;</code></pre><p>test2.sh</p><pre><code>#!/bin/bash#使用 . 号来引用test1.sh 文件. ./test1.sh# 或者使用以下包含文件代码# source ./test1.shecho $name</code></pre><blockquote><p>注：被包含的文件 test1.sh 不需要可执行权限。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 技术</title>
      <link href="/2021/07/06/docker/"/>
      <url>/2021/07/06/docker/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h1><p>docker是可以以极低资源运行的一个独立于文件系统的一个空间</p><h2 id="几个基本概念"><a href="#几个基本概念" class="headerlink" title="几个基本概念"></a>几个基本概念</h2><ul><li><code>image</code>  镜像， 类似于类的概念</li><li><code>container</code> 容器， 类似于实例的概念</li></ul><h2 id="docker-在windows下的使用"><a href="#docker-在windows下的使用" class="headerlink" title="docker 在windows下的使用"></a>docker 在windows下的使用</h2><p>docker一般是Linux系统下的工具，但是当windows出了个WSL后，docker就以一个WSL在windows下运行了。</p><p>每一个WSL在windows中都是独立的<code>vhdx</code>文件</p><p>可以通过<code>wsl -l -v</code> 查看docker文件， 通过<code>wsl -d docker-desktop</code>进入</p><h3 id="windows下的配置"><a href="#windows下的配置" class="headerlink" title="windows下的配置"></a>windows下的配置</h3><h4 id="修改存储位置"><a href="#修改存储位置" class="headerlink" title="修改存储位置"></a>修改存储位置</h4><ul><li><a href="https://blog.csdn.net/austindev/article/details/110387609">参考</a>这篇文章</li></ul><p>原理是将docker<code>export</code>出来后，<code>import</code>到新的地方</p><p>我保存的地方是<code>D:\Subsystem\docker-desktop-data</code></p><h4 id="关于image到底存在哪里"><a href="#关于image到底存在哪里" class="headerlink" title="关于image到底存在哪里"></a>关于image到底存在哪里</h4><ul><li><a href="https://www.freecodecamp.org/news/where-are-docker-images-stored-docker-container-paths-explained/">这篇文章</a>讲述了image存放的问题。</li></ul><p>windows是按照虚拟机的方式存储，而要进入这个虚拟机是通过各个images，命令如下：</p><p><code>docker run -it --privileged --pid=host &lt;image&gt; nsenter -t 1 -m -u -i bash</code></p><p>而每个image其实是通过底下一层image叠加上来的，所以可以找到<code>/var/lib/docker/overlay2</code>中每一层叠加的内容</p><h1 id="docker-常用命令"><a href="#docker-常用命令" class="headerlink" title="docker 常用命令"></a>docker 常用命令</h1><ul><li><a href="https://www.runoob.com/docker/docker-command-manual.html">这里</a>是常用命令大全</li></ul><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>在获取镜像前，可以通过<code>docker search</code> 来镜像查找相关内容。但是有的是需要特定版本的，这个需要先在<a href="https://hub.docker.com/">hub.docker.com</a>上确认版本。</p><ul><li><code>docker pull &lt;镜像&gt;:&lt;版本&gt;</code></li></ul><h2 id="创建自己的镜像"><a href="#创建自己的镜像" class="headerlink" title="创建自己的镜像"></a>创建自己的镜像</h2><p>方法是使用<code>Dockerfile</code>，在里面写好后使用</p><p><code>docker build -t &lt;image_name&gt; .</code> 创建</p><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><ul><li><code>docker ps</code> 查看运行中的容器</li><li><code>docker ps -a</code> 查看所有容器</li><li><code>docker images</code> 查看存在的镜像</li></ul><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>以<code>docker run</code>开头</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>--name &lt;alias&gt;</code></td><td align="center">容器别名</td></tr><tr><td align="center"><code>-v &lt;主机文件&gt;:&lt;容器文件&gt;</code></td><td align="center">挂载如果没有文件会自动创建</td></tr><tr><td align="center"><code>-it</code></td><td align="center">交互界面</td></tr><tr><td align="center"><code>-d</code></td><td align="center">后台运行</td></tr><tr><td align="center"><code>-p &lt;主机端口&gt;:&lt;容器端口&gt;</code></td><td align="center">将主机的端口映射到容器的端口中</td></tr><tr><td align="center"><code>-e &lt;环境变量=Value&gt;</code></td><td align="center">设置环境变量</td></tr></tbody></table><p>例子：</p><pre><code class="bash">docker run --name  myphp-fpm -v ~/nginx/www:/www  -d php:5.6-fpm</code></pre><pre><code class="bash">docker run --name apache -v $PWD:/usr/local/apache2/htdocs -p 8088:80  -it httpd /bin/bash</code></pre><pre><code class="bash">docker run -it httpd /bin/bash</code></pre><p>像<code>php</code>这样的可能会立马就退出了，所以需要打开一个Shell来保活。</p><pre><code class="bash">docker run -itd php bash</code></pre><h2 id="容器执行命令"><a href="#容器执行命令" class="headerlink" title="容器执行命令"></a>容器执行命令</h2><p>以<code>docker exec</code> 开头</p><ul><li><code>-it</code> 交互</li></ul><p>例子：</p><ul><li><code>docker exec apache ls /usr/local/apache2/htdocs</code></li><li><code>docker exec -it apache /bin/bash</code></li></ul><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>当创建了容器后会一直保留，所以需要删除</p><ul><li><p>删除所有退出的容器</p><pre><code class="bash">docker rm -v `docker ps -aq -f status=exited`</code></pre></li><li><p>删除镜像</p><pre><code class="bash">docker rmi &lt;image ID&gt;</code></pre></li></ul><p>docker 提供了更为简单的方法</p><pre><code>docker system prune #将对没有用的容器的网络进行删除docker container prune # 删除所有退出状态的容器docker volume prune # 删除未被使用的数据卷docker image prune # 删除 dangling 或所有未被使用的镜像</code></pre><ul><li><a href="https://www.cnblogs.com/sparkdev/p/9177283.html">参考文章</a></li></ul><h2 id="Commit容器"><a href="#Commit容器" class="headerlink" title="Commit容器"></a>Commit容器</h2><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul><li><code>Ctrl + P + Q</code> 退出并后台运行</li></ul><h1 id="Docker-容器间的通讯"><a href="#Docker-容器间的通讯" class="headerlink" title="Docker 容器间的通讯"></a>Docker 容器间的通讯</h1><ul><li><a href="https://my.oschina.net/thinwonton/blog/2993309">这里</a>是参考文章</li></ul><p>原理是docker内置了Bridge网桥组件，各个容器会分配IP地址，但是只有自定义的Bridge网络才能互相通讯</p><ul><li><p>创建自定义Bridge网络</p><ul><li><code>docker network create --driver bridge busybox_bridge</code></li></ul></li><li><p>将容器绑定到自定义Bridge网络中</p><ul><li><code>docker run -itd --network busybox_bridge --name busybox5 busybox</code></li></ul></li></ul><h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><p><code>docker-compose</code>是可以将多个镜像通过一套制定的规则统一运行起来的工具。极大的方便了每次启动docker需要麻烦配置的动作。</p><p>使用<code>YAML</code>文件配置</p><p><a href="https://cch20094.medium.com/docker-compose%E6%9E%B6%E8%A8%ADphp-mysql-apache-710321374758">这篇</a>介绍了如何使用<code>docker-compose</code>来搭建<code>PHP + Apache + MySql</code>的环境</p><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="Docker-容器的端口修改"><a href="#Docker-容器的端口修改" class="headerlink" title="Docker 容器的端口修改"></a>Docker 容器的端口修改</h2><ol><li><p>关闭容器 <code>docker stop &lt;container&gt;</code></p></li><li><p>进入镜像的存储地方</p><ul><li><code>docker run -it --privileged --pid=host &lt;image&gt; nsenter -t 1 -m -u -i bash</code></li></ul></li><li><p>找到存储的容器点</p><ul><li><code>cd /var/lib/docker/containers/&lt;contian ID&gt;</code></li></ul></li><li><p>修改hostconfig.json 和 config.v2.json</p></li></ol><pre><code># vim hostconfig.json&quot;PortBindings&quot;:&#123;&quot;5711/tcp&quot;:[&#123;&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;5711&quot;&#125;]&#125;#vim config.v2.json&quot;ExposedPorts&quot;:&#123;&quot;5711/tcp&quot;:&#123;&#125;&#125;&quot;Ports&quot;:&#123;&quot;5711/tcp&quot;:[&#123;&quot;HostIp&quot;:&quot;0.0.0.0&quot;,&quot;HostPort&quot;:&quot;5711&quot;&#125;]&#125;</code></pre><ol start="5"><li>重启服务 <code>systemctl restart docker</code></li></ol><h2 id="docker-连接-hackthebox"><a href="#docker-连接-hackthebox" class="headerlink" title="docker 连接 hackthebox"></a>docker 连接 hackthebox</h2><p>问题1：<br>/dev/net/tun: not the file</p><ul><li><a href="https://stackoverflow.com/questions/30547484/calling-openconnect-vpn-client-in-docker-container-shows-tunsetiff-failed-opera">解决连接</a></li></ul><pre><code>docker run -it --privileged mykali /bin/bash</code></pre><p>加入所有权限，或者只加入一个能力<code>--cap-add SYS_NET_ADMIN --device /dev/net/tun </code></p><p>问题2：<br><code> Linux can&#39;t add IPv6 to interface tun0</code></p><p>没有开启ipv6</p><ul><li><code>--sysctl net.ipv6.conf.all.disable_ipv6=0</code></li></ul><h2 id="Docker-kali-connect-to-hackthebox"><a href="#Docker-kali-connect-to-hackthebox" class="headerlink" title="Docker kali connect to hackthebox"></a>Docker kali connect to hackthebox</h2><ul><li><a href="https://amar-laksh.github.io/2019/08/24/Setting-up-Kali-docker-for-HackTheBox.html">参考链接</a></li></ul><p>端口转发</p><pre><code>socat TCP4-LISTEN:1633,reuseaddr,fork TCP4:10.10.10.28:80</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 部署</title>
      <link href="/2021/07/05/hexo-%E9%83%A8%E7%BD%B2/"/>
      <url>/2021/07/05/hexo-%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li><a href="https://hexo.io/zh-cn/docs/">hexo 的文档</a></li></ul><p><code>hexo</code>基于<code>Node.js</code>开发，安装简单</p><pre><code>npm install hexo -g</code></pre><blockquote><p>如果要部署的话，<code>npm install</code>就可以了，因为<code>node_module</code>中已经包含了<code>hexo</code></p></blockquote><h2 id="安装3-hexo主题"><a href="#安装3-hexo主题" class="headerlink" title="安装3-hexo主题"></a>安装3-hexo主题</h2><ul><li><a href="https://github.com/yelog/hexo-theme-3-hexo">3-hexo 的文档</a></li></ul><h2 id="hexo-的基本使用"><a href="#hexo-的基本使用" class="headerlink" title="hexo 的基本使用"></a>hexo 的基本使用</h2><pre><code>hexo new [title]   # 按照模板创建新的post文章hexo new draft [title]  # 创建一个草稿hexo generate      # 静态编译hexo list post     # 查看已发布的文章hexo publish draft &lt;filename&gt;      # 将草稿draft 转到 posthexo server --draft   # 将草稿也渲染出来</code></pre><h1 id="在Github上部署"><a href="#在Github上部署" class="headerlink" title="在Github上部署"></a>在Github上部署</h1><p>我使用的方式为Action部署到<code>gh-page</code>分支上</p><p><code>.github/workflows/hexo.yml</code> 文件</p><pre><code>name: Deploy Github pageson:  push:    branches:      - masterjobs:  build-and-deploy:    runs-on: ubuntu-latest    steps:    - name: Checkout      uses: actions/checkout@master      with:        persist-credentials: false    - name: Install and Build      run: |        npm install        node_modules/hexo/bin/hexo generate    - name: Deploy      uses: JamesIves/github-pages-deploy-action@releases/v3      with:        ACCESS_TOKEN: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;        BRANCH: gh-pages        FOLDER: public        BUILD_SCRIPT: npm install &amp;&amp; node_modules/hexo/bin/hexo generate</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docusaurus 实现搜索功能</title>
      <link href="/2021/06/28/docu%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/"/>
      <url>/2021/06/28/docu%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="Docusaurus-实现搜索功能"><a href="#Docusaurus-实现搜索功能" class="headerlink" title="Docusaurus 实现搜索功能"></a>Docusaurus 实现搜索功能</h1><p>Docusaurus 官方给出了一个添加搜索的方式<a href="https://docusaurus.io/zh-CN/docs/search"> Algolia DocSearch</a>，但是这个搜索插件需要得到Algolia官方的认证，如果你的网站还处于建设阶段，那么就不会被允许使用。</p><p>在网上搜索后发现了<a href="https://github.com/cmfcmf/docusaurus-search-local">search-local</a>的插件，这个插件为本地离线搜索。</p><ul><li><a href="https://docusaurus.io/feedback/p/offline-search">这里</a>是关于离线搜索的讨论</li></ul><h2 id="docusaurus-lunr-search-使用方法"><a href="#docusaurus-lunr-search-使用方法" class="headerlink" title="docusaurus-lunr-search 使用方法"></a>docusaurus-lunr-search 使用方法</h2><h3 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h3><pre><code>yarn add @cmfcmf/docusaurus-search-local</code></pre><p>注意，在官方文档中是不支持中文搜索的。在查看源码后发现，这个插件使用的是<a href="https://github.com/MihaiValentin/lunr-languages">lunr-language</a>来进行分词的，<br>在最新版本中已经包含了中文分词，并且依赖<a href="https://www.npmjs.com/package/nodejieba">nodejieba</a>。</p><p>所以要再安装<code>nodejieba</code></p><pre><code>yarn nodejieba</code></pre><blockquote><p><code>nodejieba</code>的安装依赖python，并且python的安装目录不能有中文<br>如果python已经安装到了中文目录，那么<code>npm install nodejieba</code>是可以安装的，然后<code>yarn install</code>。<br>千万别直接<code>yarn</code>。这将会导致代码框中的copy无法使用。</p></blockquote><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><pre><code>module.exports = &#123;  plugins: [    [      require.resolve(&#39;@cmfcmf/docusaurus-search-local&#39;),      &#123;        indexDocs: true,        indexBlog: true,        docsRouteBasePath: &#39;/doc&#39;,        blogRouteBasePath: &#39;/blog&#39;,        language: [&#39;en&#39;, &#39;zh&#39;],      &#125;    ],  ],&#125;</code></pre><p>最后编译 <code>npm run build</code> 即可。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这个插件只能在静态页面中生效，也就是部署了之后才能看到</p><pre><code>yarn build</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docusaurus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docusaurus 报错清单</title>
      <link href="/2021/06/28/docu%E6%8A%A5%E9%94%99%E6%B8%85%E5%8D%95/"/>
      <url>/2021/06/28/docu%E6%8A%A5%E9%94%99%E6%B8%85%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h2 id="gyp-ERR-stack-Error-EACCES"><a href="#gyp-ERR-stack-Error-EACCES" class="headerlink" title="gyp ERR! stack Error: EACCES"></a>gyp ERR! stack Error: EACCES</h2><ul><li>参考<a href="https://stackoverflow.com/questions/52231289/gyp-err-stack-error-eacces-permission-denied-mkdir-var-www-project-name-no">这篇文章</a></li></ul><pre><code>apt install python3 npm install yarn -gln -s /usr/lib/node-v14.17.1-linux-x64/bin/yarn /usr/local/bin/yarnln -s /usr/lib/node-v14.17.1-linux-x64/bin/yarnpkg /usr/local/bin/yarnpkgyarn</code></pre><p>尽量使用<code>yarn</code>作为包管理。</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docusaurus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docusaurus 的多实例文档部署</title>
      <link href="/2021/06/23/docu-%E7%9A%84%E5%A4%9A%E5%AE%9E%E4%BE%8B%E6%96%87%E6%A1%A3/"/>
      <url>/2021/06/23/docu-%E7%9A%84%E5%A4%9A%E5%AE%9E%E4%BE%8B%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Docusaurus-的多实例文档部署"><a href="#Docusaurus-的多实例文档部署" class="headerlink" title="Docusaurus 的多实例文档部署"></a>Docusaurus 的多实例文档部署</h1><p>要实现多实例文档部署其实非常简单，按照<a href="https://docusaurus.io/zh-CN/docs/docs-multi-instance">官方文档</a>就可以操作。但是里面有一些坑需要回避。</p><p>有两种部署方式：</p><ol><li>在<code>doc</code>文件夹内部再添加文件夹，这种方式可以控制版本。</li><li>在根目录下添加文件夹，这种方式不能控制版本。</li></ol><p>本篇讲述第2种方式。第一种方式可以参考<a href="https://www.gitmemory.com/issue/facebook/docusaurus/3299/675409985">这篇文章</a>。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><pre><code>docs/- doc1.mdresources/- doc2.md</code></pre><p>如上加入了<code>resources</code>文件夹，里面包含了<code>doc2.md</code>文件。</p><h2 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h2><p>在<code>docusaurus.config.js</code>文件中需要做出如下<strong>最小</strong>修改：</p><pre><code class="js">module.exports = &#123;  plugins: [    [      &#39;@docusaurus/plugin-content-docs&#39;,      &#123;        id: &#39;resources&#39;,        path: &#39;resources&#39;,        routeBasePath: &#39;resources&#39;,        sidebarPath: require.resolve(&#39;./sidebarsResources.js&#39;),        // ... 其他设置      &#125;,    ],  ],  themeConfig: &#123;    navbar: &#123;      items: [&#123;      &#123;        // highlight-next-line        to: &#39;/resources/doc2&#39;,   // 这里要指定具体的index文档        activeBasePath: &#39;resources&#39;,        label: &#39;这里是文档2&#39;,        position: &#39;left&#39;      &#125;,      &#125;]    &#125;  &#125;&#125;;</code></pre><p>最后是对sidebars的调整</p><pre><code class="js">module.exports = &#123;    resources: [&#123; type: &#39;autogenerated&#39;, dirName: &#39;.&#39; &#125;],&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docusaurus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Github Pages 部署 Blog</title>
      <link href="/2021/06/22/github-pages-%E9%83%A8%E7%BD%B2/"/>
      <url>/2021/06/22/github-pages-%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-Github-Pages-部署-Blog"><a href="#使用-Github-Pages-部署-Blog" class="headerlink" title="使用 Github Pages 部署 Blog"></a>使用 Github Pages 部署 Blog</h1><p>要使用 Github Pages 来部署博客，首先需要选择使用什么静态框架。</p><p>这里我最终选择了<a href="https://docusaurus.io/zh-CN/docs">Docusaurus</a></p><p>开发与部署的简要流程如下：</p><ol><li><p>使用<code>Docusaurus</code>的脚手架创建初始项目</p><pre><code>npx @docusaurus/init@latest init my-website classic</code></pre></li><li><p>修改<code>docusaurus.config.js</code>文件中3个重要内容</p></li></ol><pre><code class="js">    url: &#39;https://elinpf.github.io&#39;,    organizationName: &#39;Elinpf&#39;,     projectName: &#39;elinpf.github.io&#39;, </code></pre><ol start="3"><li><p>在Github上创建同名仓库<code>Elinpf/Elinpf.github.io</code></p></li><li><p>发布<code>master</code>和<code>gh-pages</code>分支</p></li></ol><pre><code class="bash">git remote add origin https://github.com/Elinpf/Elinpf.github.io.gitgit push origin mastergit branch -M gh-pagesgit push origin gh-pages</code></pre><ol start="5"><li>将<code>Setting</code>中的Pages发布源改为<code>gh-pages</code>分支</li></ol><p><img src="/2021/06/22/github-pages-%E9%83%A8%E7%BD%B2/1.png"></p><ol start="6"><li>将<code>Setting</code>中的<code>Secrets</code>添加一个<code>ACCESS_TOKEN</code>(这里的token就是用户授权的token值，<a href="https://docs.github.com/en/github/authenticating-to-github/keeping-your-account-and-data-secure/creating-a-personal-access-token">参考这里增加新的授权</a>)</li></ol><p><img src="/2021/06/22/github-pages-%E9%83%A8%E7%BD%B2/2.png"></p><ol start="7"><li>在项目中添加文件<code>.github/workflows/docusaurus.yml</code>，来写Action用于自动部署（具体含义参考<a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">这篇文章</a>）</li></ol><pre><code class="yaml">name: Deploy Github pageson:  push:    branches:      - masterjobs:  build-and-deploy:    runs-on: ubuntu-latest    steps:    - name: Checkout      uses: actions/checkout@master      with:        persist-credentials: false    - name: Install and Build      run: |        npm install        npm run-script build     - name: Deploy      uses: JamesIves/github-pages-deploy-action@releases/v3      with:        ACCESS_TOKEN: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;        BRANCH: gh-pages        FOLDER: build        BUILD_SCRIPT: npm install &amp;&amp; npm run build</code></pre><ol start="8"><li>再次提交就可以了</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> docusaurus </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
