<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>shell 速查表</title>
      <link href="/2021/07/06/shell-%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
      <url>/2021/07/06/shell-%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><pre><code>#!/bin/bashmsg=&quot;hello world&quot;echo $msg</code></pre><p><strong>变量名的命名须遵循如下规则：</strong></p><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li></ul><h1 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h1><pre><code>#!/bin/bashecho &quot;执行的文件名：$0&quot;;echo &quot;第一个参数为：$1&quot;;echo &quot;第二个参数为：$2&quot;;echo &quot;第三个参数为：$3&quot;;</code></pre><p><strong>脚本内获取参数的格式为：</strong></p><p>$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……</p><p><strong>另外，还有几个特殊字符用来处理参数：</strong></p><table><thead><tr><th align="center">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center"><code>$#</code></td><td align="left">传递到脚本的参数个数</td></tr><tr><td align="center"><code>$*</code></td><td align="left">以一个单字符串显示所有向脚本传递的参数。如”$*”用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。</td></tr><tr><td align="center"><code>$$</code></td><td align="left">脚本运行的当前进程ID号</td></tr><tr><td align="center"><code>$!</code></td><td align="left">后台运行的最后一个进程的ID号</td></tr><tr><td align="center"><code>$@</code></td><td align="left">与<code>$*</code>相同，但是使用时加引号，并在引号中返回每个参数。如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。</td></tr><tr><td align="center"><code>$-</code></td><td align="left">显示Shell使用的当前选项，与set命令功能相同。</td></tr><tr><td align="center"><code>$?</code></td><td align="left">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr></tbody></table><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><pre><code>#!/bin/bashmy_array=(A B &quot;C&quot; D)echo &quot;第一个元素为: $&#123;my_array[0]&#125;&quot;echo &quot;第二个元素为: $&#123;my_array[1]&#125;&quot;echo &quot;第三个元素为: $&#123;my_array[2]&#125;&quot;echo &quot;第四个元素为: $&#123;my_array[3]&#125;&quot;echo &quot;数组的元素为: $&#123;my_array[*]&#125;&quot;echo &quot;数组的元素为: $&#123;my_array[@]&#125;&quot;echo &quot;数组元素个数为: $&#123;#my_array[*]&#125;&quot;echo &quot;数组元素个数为: $&#123;#my_array[@]&#125;&quot;</code></pre><h1 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h1><blockquote><p>原生 bash 不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p></blockquote><p>expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</p><h2 id="1-算数运算符"><a href="#1-算数运算符" class="headerlink" title="1. 算数运算符"></a>1. 算数运算符</h2><pre><code>#!/bin/bashecho &quot;2加2等于&quot;`expr 2 + 2`echo &quot;2减2等于&quot;`expr 2 - 2`echo &quot;2乘2等于&quot;`expr 2 \* 2`echo &quot;2除2等于&quot;`expr 2 / 2`echo &quot;2除2取余&quot;`expr 2 % 2`</code></pre><h2 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2. 关系运算符"></a>2. 关系运算符</h2><pre><code>#!/bin/basha=10b=20if [ $a -eq $b ] # 检测两个数是否相等，相等返回 true。if [ $a -ne $b ] # 检测两个数是否不相等，不相等返回 true。if [ $a -gt $b ] # 检测左边的数是否大于右边的，如果是，则返回 true。if [ $a -lt $b ] # 检测左边的数是否小于右边的，如果是，则返回 true。if [ $a -ge $b ] # 检测左边的数是否大于等于右边的，如果是，则返回 true。if [ $a -le $b ] # 检测左边的数是否小于等于右边的，如果是，则返回 true。</code></pre><h2 id="3-布尔运算符"><a href="#3-布尔运算符" class="headerlink" title="3. 布尔运算符"></a>3. 布尔运算符</h2><pre><code>#!/bin/bashif [ ! false ]       # 非运算，返回 trueif [ true -o false ] # 或运算，返回 trueif [ true -a false ] # 与运算，返回 false</code></pre><h2 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4. 逻辑运算符"></a>4. 逻辑运算符</h2><pre><code>#!/bin/basha=10b=20if [[ $a -lt $b &amp;&amp; $a -gt $b ]]   # 逻辑的 AND, 返回 falseif [ $a -lt $b ] &amp;&amp; [ $a -gt $b ] # 逻辑的 AND, 返回 falseif [[ $a -lt $b || $a -gt $b ]]   # 逻辑的 OR, 返回 trueif [ $a -lt $b ] || [ $a -gt $b ] # 逻辑的 OR, 返回 true</code></pre><h2 id="5-字符串运算符"><a href="#5-字符串运算符" class="headerlink" title="5. 字符串运算符"></a>5. 字符串运算符</h2><pre><code>#!/bin/basha=&quot;abc&quot;b=&quot;efg&quot;if [ $a = $b ]   # 检测两个字符串是否相等，相等返回 true。if [ $a != $b ]  # 检测两个字符串是否相等，不相等返回 true。if [ -z $a ]     # 检测字符串长度是否为0，为0返回 true。if [ -n &quot;$a&quot; ]   # 检测字符串长度是否为0，不为0返回 true。if [ $a ]        # 检测字符串是否为空，不为空返回 true。</code></pre><h2 id="6-文件测试运算符"><a href="#6-文件测试运算符" class="headerlink" title="6. 文件测试运算符"></a>6. 文件测试运算符</h2><p>文件测试运算符用于检测 Unix 文件的各种属性。</p><table><thead><tr><th align="center">操作符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">-b file</td><td align="left">检测文件是否是块设备文件，如果是，则返回 true。</td></tr><tr><td align="center">-c file</td><td align="left">检测文件是否是字符设备文件，如果是，则返回 true。</td></tr><tr><td align="center">-d file</td><td align="left">检测文件是否是目录，如果是，则返回 true。</td></tr><tr><td align="center">-f file</td><td align="left">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td></tr><tr><td align="center">-g file</td><td align="left">检测文件是否设置了 SGID 位，如果是，则返回 true。</td></tr><tr><td align="center">-k file</td><td align="left">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td></tr><tr><td align="center">-p file</td><td align="left">检测文件是否是有名管道，如果是，则返回 true。</td></tr><tr><td align="center">-u file</td><td align="left">检测文件是否设置了 SUID 位，如果是，则返回 true。</td></tr><tr><td align="center">-r file</td><td align="left">检测文件是否可读，如果是，则返回 true。</td></tr><tr><td align="center">-w file</td><td align="left">检测文件是否可写，如果是，则返回 true。</td></tr><tr><td align="center">-x file</td><td align="left">检测文件是否可执行，如果是，则返回 true。</td></tr><tr><td align="center">-s file</td><td align="left">检测文件是否为空（文件大小是否大于0），不为空返回 true。</td></tr><tr><td align="center">-e file</td><td align="left">检测文件（包括目录）是否存在，如果是，则返回 true。</td></tr></tbody></table><h1 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h1><h2 id="1-命令格式"><a href="#1-命令格式" class="headerlink" title="1. 命令格式"></a>1. 命令格式</h2><pre><code>#!/bin/bashecho &quot;It is a test&quot;echo It is a testecho &quot;\&quot;It is a test\&quot;&quot;      # 转义name=Chrisecho &quot;$name is handsome&quot;echo -e &quot;OK! \n&quot;             # 显示换行 -e 开启转义echo &quot;It is a test&quot; &gt; myfile # 显示结果定向至文件echo &#39;$name\&quot;&#39;               # 原样输入字符串，不进行转义或取变量（使用单引号）echo `date`                  # 显示命令执行结构</code></pre><h2 id="2-颜色显示"><a href="#2-颜色显示" class="headerlink" title="2. 颜色显示"></a>2. 颜色显示</h2><pre><code>echo -e &quot;\033[字背景颜色；文字颜色m字符串\033[0m&quot;echo -e “\033[30m 黑色字 \033[0m”echo -e “\033[31m 红色字 \033[0m”echo -e “\033[32m 绿色字 \033[0m”echo -e “\033[33m 黄色字 \033[0m”echo -e “\033[34m 蓝色字 \033[0m”echo -e “\033[35m 紫色字 \033[0m”echo -e “\033[36m 天蓝字 \033[0m”echo -e “\033[37m 白色字 \033[0m”echo -e “\033[40;37m 黑底白字 \033[0m”echo -e “\033[41;37m 红底白字 \033[0m”echo -e “\033[42;37m 绿底白字 \033[0m”echo -e “\033[43;37m 黄底白字 \033[0m”echo -e “\033[44;37m 蓝底白字 \033[0m”echo -e “\033[45;37m 紫底白字 \033[0m”echo -e “\033[46;37m 天蓝底白字 \033[0m”echo -e “\033[47;30m 白底黑字 \033[0m”\33[0m 关闭所有属性\33[1m 设置高亮度\33[4m 下划线\33[5m 闪烁\33[7m 反显\33[8m 消隐\33[30m — \33[37m 设置前景色\33[40m — \33[47m 设置背景色\33[nA 光标上移n行\33[nB 光标下移n行\33[nC 光标右移n行\33[nD 光标左移n行\33[y;xH设置光标位置\33[2J 清屏\33[K 清除从光标到行尾的内容\33[s 保存光标位置\33[u 恢复光标位置\33[?25l 隐藏光标\33[?25h 显示光标</code></pre><h1 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a>sprintf</h1><pre><code>#!/bin/bashprintf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kg  printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876</code></pre><p>结果：</p><pre><code>姓名     性别   体重kg郭靖     男      66.12杨过     男      48.65郭芙     女      47.99</code></pre><blockquote><p><code>%s %c %d %f</code> 都是格式替代符<br><code>d</code>: Decimal 十进制整数 – 对应位置参数必须是十进制整数，否则报错！<br><code>s</code>: String 字符串 – 对应位置参数必须是字符串或者字符型，否则报错！<br><code>c</code>: Char 字符 – 对应位置参数必须是字符串或者字符型，否则报错！<br><code>f</code>: Float 浮点 – 对应位置参数必须是数字型，否则报错！<br><code>%-10s</code> 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐）,任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。<br><code>%-4.2f</code> 指格式化为小数，其中.2指保留2位小数。</p></blockquote><h1 id="test"><a href="#test" class="headerlink" title="test"></a>test</h1><p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p><pre><code>#!/bin/bashnum1=100num2=100if test $[num1] -eq $[num2]</code></pre><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="1-if-else"><a href="#1-if-else" class="headerlink" title="1. if-else"></a>1. if-else</h2><pre><code>#!/bin/basha=10b=20if [ $a == $b ]then   echo &quot;a 等于 b&quot;elif [ $a -gt $b ]then   echo &quot;a 大于 b&quot;elif [ $a -lt $b ]then   echo &quot;a 小于 b&quot;else   echo &quot;没有符合的条件&quot;fi</code></pre><h2 id="2-for"><a href="#2-for" class="headerlink" title="2. for"></a>2. for</h2><pre><code>#!/bin/bashfor loop in 1 2 3 4 5do    echo &quot;The value is: $loop&quot;done</code></pre><h2 id="3-while"><a href="#3-while" class="headerlink" title="3. while"></a>3. while</h2><pre><code>#!/bin/bashint=1while(( $int&lt;=5 ))do    echo $int    let &quot;int++&quot;done</code></pre><h2 id="4-case"><a href="#4-case" class="headerlink" title="4. case"></a>4. case</h2><pre><code>#!/bin/bashecho &#39;输入 1 到 4 之间的数字:&#39;echo &#39;你输入的数字为:&#39;read aNumcase $aNum in    1)  echo &#39;你选择了 1&#39;    ;;    2)  echo &#39;你选择了 2&#39;    ;;    3)  echo &#39;你选择了 3&#39;    ;;    4)  echo &#39;你选择了 4&#39;    ;;    *)  echo &#39;你没有输入 1 到 4 之间的数字&#39;    ;;esac</code></pre><h2 id="5-break"><a href="#5-break" class="headerlink" title="5. break"></a>5. break</h2><p>break命令允许跳出所有循环（终止执行后面的所有循环）。</p><pre><code>#!/bin/bashwhile :do    echo -n &quot;输入 1 到 5 之间的数字:&quot;    read aNum    case $aNum in        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;        ;;        *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot;            break        ;;    esacdone</code></pre><h2 id="6-continue"><a href="#6-continue" class="headerlink" title="6. continue"></a>6. continue</h2><p>跳出当前循环。</p><pre><code>#!/bin/bashwhile :do    echo -n &quot;输入 1 到 5 之间的数字: &quot;    read aNum    case $aNum in        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;        ;;        *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot;            continue            echo &quot;游戏结束&quot;        ;;    esacdone</code></pre><h2 id="7-until"><a href="#7-until" class="headerlink" title="7. until"></a>7. until</h2><pre><code>#!/bin/basha=0until [ ! $a -lt 10 ]do   echo $a   a=`expr $a + 1`done</code></pre><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><pre><code>#!/bin/bashfunWithParam()&#123;    echo &quot;第一个参数为 $1 !&quot;    echo &quot;第二个参数为 $2 !&quot;    echo &quot;第十个参数为 $10 !&quot;    echo &quot;第十个参数为 $&#123;10&#125; !&quot;    echo &quot;第十一个参数为 $&#123;11&#125; !&quot;    echo &quot;参数总数有 $# 个!&quot;    echo &quot;作为一个字符串输出所有参数 $* !&quot;&#125;funWithParam 1 2 3 4 5 6 7 8 9 34 73</code></pre><p>结果： </p><pre><code>第一个参数为 1 !第二个参数为 2 !第十个参数为 10 !第十个参数为 34 !第十一个参数为 73 !参数总数有 11 个!作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !</code></pre><h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><pre><code>#!/bin/bashwho &gt; today.log # 执行结果覆盖到文件 today.logecho &quot;菜鸟教程：www.runoob.com&quot; &gt;&gt; today.log # 执行结果追加到文件 today.logwc -l &lt; today.log # 统计 today.log 行数wc -l &lt;&lt; EOF    李白    苏轼    王勃EOF</code></pre><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><p>test1.sh</p><pre><code>#!/bin/bashname=&quot;Chris&quot;</code></pre><p>test2.sh</p><pre><code>#!/bin/bash#使用 . 号来引用test1.sh 文件. ./test1.sh# 或者使用以下包含文件代码# source ./test1.shecho $name</code></pre><blockquote><p>注：被包含的文件 test1.sh 不需要可执行权限。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 技术</title>
      <link href="/2021/07/06/docker/"/>
      <url>/2021/07/06/docker/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h1><p>docker是可以以极低资源运行的一个独立于文件系统的一个空间</p><h2 id="几个基本概念"><a href="#几个基本概念" class="headerlink" title="几个基本概念"></a>几个基本概念</h2><ul><li><code>image</code>  镜像， 类似于类的概念</li><li><code>container</code> 容器， 类似于实例的概念</li></ul><h2 id="docker-在windows下的使用"><a href="#docker-在windows下的使用" class="headerlink" title="docker 在windows下的使用"></a>docker 在windows下的使用</h2><p>docker一般是Linux系统下的工具，但是当windows出了个WSL后，docker就以一个WSL在windows下运行了。</p><p>每一个WSL在windows中都是独立的<code>vhdx</code>文件</p><p>可以通过<code>wsl -l -v</code> 查看docker文件， 通过<code>wsl -d docker-desktop</code>进入</p><h3 id="windows下的配置"><a href="#windows下的配置" class="headerlink" title="windows下的配置"></a>windows下的配置</h3><h4 id="修改存储位置"><a href="#修改存储位置" class="headerlink" title="修改存储位置"></a>修改存储位置</h4><ul><li><a href="https://blog.csdn.net/austindev/article/details/110387609">参考</a>这篇文章</li></ul><p>原理是将docker<code>export</code>出来后，<code>import</code>到新的地方</p><p>我保存的地方是<code>D:\Subsystem\docker-desktop-data</code></p><h4 id="关于image到底存在哪里"><a href="#关于image到底存在哪里" class="headerlink" title="关于image到底存在哪里"></a>关于image到底存在哪里</h4><ul><li><a href="https://www.freecodecamp.org/news/where-are-docker-images-stored-docker-container-paths-explained/">这篇文章</a>讲述了image存放的问题。</li></ul><p>windows是按照虚拟机的方式存储，而要进入这个虚拟机是通过各个images，命令如下：</p><p><code>docker run -it --privileged --pid=host &lt;image&gt; nsenter -t 1 -m -u -i bash</code></p><p>而每个image其实是通过底下一层image叠加上来的，所以可以找到<code>/var/lib/docker/overlay2</code>中每一层叠加的内容</p><h1 id="docker-常用命令"><a href="#docker-常用命令" class="headerlink" title="docker 常用命令"></a>docker 常用命令</h1><ul><li><a href="https://www.runoob.com/docker/docker-command-manual.html">这里</a>是常用命令大全</li></ul><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>在获取镜像前，可以通过<code>docker search</code> 来镜像查找相关内容。但是有的是需要特定版本的，这个需要先在<a href="https://hub.docker.com/">hub.docker.com</a>上确认版本。</p><ul><li><code>docker pull &lt;镜像&gt;:&lt;版本&gt;</code></li></ul><h2 id="创建自己的镜像"><a href="#创建自己的镜像" class="headerlink" title="创建自己的镜像"></a>创建自己的镜像</h2><p>方法是使用<code>Dockerfile</code>，在里面写好后使用</p><p><code>docker build -t &lt;image_name&gt; .</code> 创建</p><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><ul><li><code>docker ps</code> 查看运行中的容器</li><li><code>docker ps -a</code> 查看所有容器</li><li><code>docker images</code> 查看存在的镜像</li></ul><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>以<code>docker run</code>开头</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>--name &lt;alias&gt;</code></td><td align="center">容器别名</td></tr><tr><td align="center"><code>-v &lt;主机文件&gt;:&lt;容器文件&gt;</code></td><td align="center">挂载如果没有文件会自动创建</td></tr><tr><td align="center"><code>-it</code></td><td align="center">交互界面</td></tr><tr><td align="center"><code>-d</code></td><td align="center">后台运行</td></tr><tr><td align="center"><code>-p &lt;主机端口&gt;:&lt;容器端口&gt;</code></td><td align="center">将主机的端口映射到容器的端口中</td></tr><tr><td align="center"><code>-e &lt;环境变量=Value&gt;</code></td><td align="center">设置环境变量</td></tr></tbody></table><p>例子：</p><pre><code class="bash">docker run --name  myphp-fpm -v ~/nginx/www:/www  -d php:5.6-fpm</code></pre><pre><code class="bash">docker run --name apache -v $PWD:/usr/local/apache2/htdocs -p 8088:80  -it httpd /bin/bash</code></pre><pre><code class="bash">docker run -it httpd /bin/bash</code></pre><p>像<code>php</code>这样的可能会立马就退出了，所以需要打开一个Shell来保活。</p><pre><code class="bash">docker run -itd php bash</code></pre><h2 id="容器执行命令"><a href="#容器执行命令" class="headerlink" title="容器执行命令"></a>容器执行命令</h2><p>以<code>docker exec</code> 开头</p><ul><li><code>-it</code> 交互</li></ul><p>例子：</p><ul><li><code>docker exec apache ls /usr/local/apache2/htdocs</code></li><li><code>docker exec -it apache /bin/bash</code></li></ul><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>当创建了容器后会一直保留，所以需要删除</p><ul><li><p>删除所有退出的容器</p><pre><code class="bash">docker rm -v `docker ps -aq -f status=exited`</code></pre></li><li><p>删除镜像</p><pre><code class="bash">docker rmi &lt;image ID&gt;</code></pre></li></ul><p>docker 提供了更为简单的方法</p><pre><code>docker system prune #将对没有用的容器的网络进行删除docker container prune # 删除所有退出状态的容器docker volume prune # 删除未被使用的数据卷docker image prune # 删除 dangling 或所有未被使用的镜像</code></pre><ul><li><a href="https://www.cnblogs.com/sparkdev/p/9177283.html">参考文章</a></li></ul><h2 id="Commit容器"><a href="#Commit容器" class="headerlink" title="Commit容器"></a>Commit容器</h2><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul><li><code>Ctrl + P + Q</code> 退出并后台运行</li></ul><h1 id="Docker-容器间的通讯"><a href="#Docker-容器间的通讯" class="headerlink" title="Docker 容器间的通讯"></a>Docker 容器间的通讯</h1><ul><li><a href="https://my.oschina.net/thinwonton/blog/2993309">这里</a>是参考文章</li></ul><p>原理是docker内置了Bridge网桥组件，各个容器会分配IP地址，但是只有自定义的Bridge网络才能互相通讯</p><ul><li><p>创建自定义Bridge网络</p><ul><li><code>docker network create --driver bridge busybox_bridge</code></li></ul></li><li><p>将容器绑定到自定义Bridge网络中</p><ul><li><code>docker run -itd --network busybox_bridge --name busybox5 busybox</code></li></ul></li></ul><h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><p><code>docker-compose</code>是可以将多个镜像通过一套制定的规则统一运行起来的工具。极大的方便了每次启动docker需要麻烦配置的动作。</p><p>使用<code>YAML</code>文件配置</p><p><a href="https://cch20094.medium.com/docker-compose%E6%9E%B6%E8%A8%ADphp-mysql-apache-710321374758">这篇</a>介绍了如何使用<code>docker-compose</code>来搭建<code>PHP + Apache + MySql</code>的环境</p><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="Docker-容器的端口修改"><a href="#Docker-容器的端口修改" class="headerlink" title="Docker 容器的端口修改"></a>Docker 容器的端口修改</h2><ol><li><p>关闭容器 <code>docker stop &lt;container&gt;</code></p></li><li><p>进入镜像的存储地方</p><ul><li><code>docker run -it --privileged --pid=host &lt;image&gt; nsenter -t 1 -m -u -i bash</code></li></ul></li><li><p>找到存储的容器点</p><ul><li><code>cd /var/lib/docker/containers/&lt;contian ID&gt;</code></li></ul></li><li><p>修改hostconfig.json 和 config.v2.json</p></li></ol><pre><code># vim hostconfig.json&quot;PortBindings&quot;:&#123;&quot;5711/tcp&quot;:[&#123;&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;5711&quot;&#125;]&#125;#vim config.v2.json&quot;ExposedPorts&quot;:&#123;&quot;5711/tcp&quot;:&#123;&#125;&#125;&quot;Ports&quot;:&#123;&quot;5711/tcp&quot;:[&#123;&quot;HostIp&quot;:&quot;0.0.0.0&quot;,&quot;HostPort&quot;:&quot;5711&quot;&#125;]&#125;</code></pre><ol start="5"><li>重启服务 <code>systemctl restart docker</code></li></ol><h2 id="docker-连接-hackthebox"><a href="#docker-连接-hackthebox" class="headerlink" title="docker 连接 hackthebox"></a>docker 连接 hackthebox</h2><p>问题1：<br>/dev/net/tun: not the file</p><ul><li><a href="https://stackoverflow.com/questions/30547484/calling-openconnect-vpn-client-in-docker-container-shows-tunsetiff-failed-opera">解决连接</a></li></ul><pre><code>docker run -it --privileged mykali /bin/bash</code></pre><p>加入所有权限，或者只加入一个能力<code>--cap-add SYS_NET_ADMIN --device /dev/net/tun </code></p><p>问题2：<br><code> Linux can&#39;t add IPv6 to interface tun0</code></p><p>没有开启ipv6</p><ul><li><code>--sysctl net.ipv6.conf.all.disable_ipv6=0</code></li></ul><h2 id="Docker-kali-connect-to-hackthebox"><a href="#Docker-kali-connect-to-hackthebox" class="headerlink" title="Docker kali connect to hackthebox"></a>Docker kali connect to hackthebox</h2><ul><li><a href="https://amar-laksh.github.io/2019/08/24/Setting-up-Kali-docker-for-HackTheBox.html">参考链接</a></li></ul><p>端口转发</p><pre><code>socat TCP4-LISTEN:1633,reuseaddr,fork TCP4:10.10.10.28:80</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 部署</title>
      <link href="/2021/07/05/hexo-%E9%83%A8%E7%BD%B2/"/>
      <url>/2021/07/05/hexo-%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li><a href="https://hexo.io/zh-cn/docs/">hexo 的文档</a></li></ul><p><code>hexo</code>基于<code>Node.js</code>开发，安装简单</p><pre><code>npm install hexo -g</code></pre><blockquote><p>如果要部署的话，<code>npm install</code>就可以了，因为<code>node_module</code>中已经包含了<code>hexo</code></p></blockquote><h2 id="安装3-hexo主题"><a href="#安装3-hexo主题" class="headerlink" title="安装3-hexo主题"></a>安装3-hexo主题</h2><ul><li><a href="https://github.com/yelog/hexo-theme-3-hexo">3-hexo 的文档</a></li></ul><h2 id="hexo-的基本使用"><a href="#hexo-的基本使用" class="headerlink" title="hexo 的基本使用"></a>hexo 的基本使用</h2><pre><code>hexo new [title]   # 按照模板创建新的post文章hexo new draft [title]  # 创建一个草稿hexo generate      # 静态编译hexo list post     # 查看已发布的文章hexo publish draft &lt;filename&gt;      # 将草稿draft 转到 posthexo server --draft   # 将草稿也渲染出来</code></pre><h1 id="在Github上部署"><a href="#在Github上部署" class="headerlink" title="在Github上部署"></a>在Github上部署</h1><p>我使用的方式为Action部署到<code>gh-page</code>分支上</p><p><code>.github/workflows/hexo.yml</code> 文件</p><pre><code>name: Deploy Github pageson:  push:    branches:      - masterjobs:  build-and-deploy:    runs-on: ubuntu-latest    steps:    - name: Checkout      uses: actions/checkout@master      with:        persist-credentials: false    - name: Install and Build      run: |        npm install        node_modules/hexo/bin/hexo generate    - name: Deploy      uses: JamesIves/github-pages-deploy-action@releases/v3      with:        ACCESS_TOKEN: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;        BRANCH: gh-pages        FOLDER: public        BUILD_SCRIPT: npm install &amp;&amp; node_modules/hexo/bin/hexo generate</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docusaurus 实现搜索功能</title>
      <link href="/2021/06/28/docu%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/"/>
      <url>/2021/06/28/docu%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="Docusaurus-实现搜索功能"><a href="#Docusaurus-实现搜索功能" class="headerlink" title="Docusaurus 实现搜索功能"></a>Docusaurus 实现搜索功能</h1><p>Docusaurus 官方给出了一个添加搜索的方式<a href="https://docusaurus.io/zh-CN/docs/search"> Algolia DocSearch</a>，但是这个搜索插件需要得到Algolia官方的认证，如果你的网站还处于建设阶段，那么就不会被允许使用。</p><p>在网上搜索后发现了<a href="https://github.com/cmfcmf/docusaurus-search-local">search-local</a>的插件，这个插件为本地离线搜索。</p><ul><li><a href="https://docusaurus.io/feedback/p/offline-search">这里</a>是关于离线搜索的讨论</li></ul><h2 id="docusaurus-lunr-search-使用方法"><a href="#docusaurus-lunr-search-使用方法" class="headerlink" title="docusaurus-lunr-search 使用方法"></a>docusaurus-lunr-search 使用方法</h2><h3 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h3><pre><code>yarn add @cmfcmf/docusaurus-search-local</code></pre><p>注意，在官方文档中是不支持中文搜索的。在查看源码后发现，这个插件使用的是<a href="https://github.com/MihaiValentin/lunr-languages">lunr-language</a>来进行分词的，<br>在最新版本中已经包含了中文分词，并且依赖<a href="https://www.npmjs.com/package/nodejieba">nodejieba</a>。</p><p>所以要再安装<code>nodejieba</code></p><pre><code>yarn nodejieba</code></pre><blockquote><p><code>nodejieba</code>的安装依赖python，并且python的安装目录不能有中文<br>如果python已经安装到了中文目录，那么<code>npm install nodejieba</code>是可以安装的，然后<code>yarn install</code>。<br>千万别直接<code>yarn</code>。这将会导致代码框中的copy无法使用。</p></blockquote><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><pre><code>module.exports = &#123;  plugins: [    [      require.resolve(&#39;@cmfcmf/docusaurus-search-local&#39;),      &#123;        indexDocs: true,        indexBlog: true,        docsRouteBasePath: &#39;/doc&#39;,        blogRouteBasePath: &#39;/blog&#39;,        language: [&#39;en&#39;, &#39;zh&#39;],      &#125;    ],  ],&#125;</code></pre><p>最后编译 <code>npm run build</code> 即可。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这个插件只能在静态页面中生效，也就是部署了之后才能看到</p><pre><code>yarn build</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docusaurus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docusaurus 报错清单</title>
      <link href="/2021/06/28/docu%E6%8A%A5%E9%94%99%E6%B8%85%E5%8D%95/"/>
      <url>/2021/06/28/docu%E6%8A%A5%E9%94%99%E6%B8%85%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h2 id="gyp-ERR-stack-Error-EACCES"><a href="#gyp-ERR-stack-Error-EACCES" class="headerlink" title="gyp ERR! stack Error: EACCES"></a>gyp ERR! stack Error: EACCES</h2><ul><li>参考<a href="https://stackoverflow.com/questions/52231289/gyp-err-stack-error-eacces-permission-denied-mkdir-var-www-project-name-no">这篇文章</a></li></ul><pre><code>apt install python3 npm install yarn -gln -s /usr/lib/node-v14.17.1-linux-x64/bin/yarn /usr/local/bin/yarnln -s /usr/lib/node-v14.17.1-linux-x64/bin/yarnpkg /usr/local/bin/yarnpkgyarn</code></pre><p>尽量使用<code>yarn</code>作为包管理。</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docusaurus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docusaurus 的多实例文档部署</title>
      <link href="/2021/06/23/docu-%E7%9A%84%E5%A4%9A%E5%AE%9E%E4%BE%8B%E6%96%87%E6%A1%A3/"/>
      <url>/2021/06/23/docu-%E7%9A%84%E5%A4%9A%E5%AE%9E%E4%BE%8B%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Docusaurus-的多实例文档部署"><a href="#Docusaurus-的多实例文档部署" class="headerlink" title="Docusaurus 的多实例文档部署"></a>Docusaurus 的多实例文档部署</h1><p>要实现多实例文档部署其实非常简单，按照<a href="https://docusaurus.io/zh-CN/docs/docs-multi-instance">官方文档</a>就可以操作。但是里面有一些坑需要回避。</p><p>有两种部署方式：</p><ol><li>在<code>doc</code>文件夹内部再添加文件夹，这种方式可以控制版本。</li><li>在根目录下添加文件夹，这种方式不能控制版本。</li></ol><p>本篇讲述第2种方式。第一种方式可以参考<a href="https://www.gitmemory.com/issue/facebook/docusaurus/3299/675409985">这篇文章</a>。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><pre><code>docs/- doc1.mdresources/- doc2.md</code></pre><p>如上加入了<code>resources</code>文件夹，里面包含了<code>doc2.md</code>文件。</p><h2 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h2><p>在<code>docusaurus.config.js</code>文件中需要做出如下<strong>最小</strong>修改：</p><pre><code class="js">module.exports = &#123;  plugins: [    [      &#39;@docusaurus/plugin-content-docs&#39;,      &#123;        id: &#39;resources&#39;,        path: &#39;resources&#39;,        routeBasePath: &#39;resources&#39;,        sidebarPath: require.resolve(&#39;./sidebarsResources.js&#39;),        // ... 其他设置      &#125;,    ],  ],  themeConfig: &#123;    navbar: &#123;      items: [&#123;      &#123;        // highlight-next-line        to: &#39;/resources/doc2&#39;,   // 这里要指定具体的index文档        activeBasePath: &#39;resources&#39;,        label: &#39;这里是文档2&#39;,        position: &#39;left&#39;      &#125;,      &#125;]    &#125;  &#125;&#125;;</code></pre><p>最后是对sidebars的调整</p><pre><code class="js">module.exports = &#123;    resources: [&#123; type: &#39;autogenerated&#39;, dirName: &#39;.&#39; &#125;],&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docusaurus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Github Pages 部署 Blog</title>
      <link href="/2021/06/22/github-pages-%E9%83%A8%E7%BD%B2/"/>
      <url>/2021/06/22/github-pages-%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-Github-Pages-部署-Blog"><a href="#使用-Github-Pages-部署-Blog" class="headerlink" title="使用 Github Pages 部署 Blog"></a>使用 Github Pages 部署 Blog</h1><p>要使用 Github Pages 来部署博客，首先需要选择使用什么静态框架。</p><p>这里我最终选择了<a href="https://docusaurus.io/zh-CN/docs">Docusaurus</a></p><p>开发与部署的简要流程如下：</p><ol><li><p>使用<code>Docusaurus</code>的脚手架创建初始项目</p><pre><code>npx @docusaurus/init@latest init my-website classic</code></pre></li><li><p>修改<code>docusaurus.config.js</code>文件中3个重要内容</p></li></ol><pre><code class="js">    url: &#39;https://elinpf.github.io&#39;,    organizationName: &#39;Elinpf&#39;,     projectName: &#39;elinpf.github.io&#39;, </code></pre><ol start="3"><li><p>在Github上创建同名仓库<code>Elinpf/Elinpf.github.io</code></p></li><li><p>发布<code>master</code>和<code>gh-pages</code>分支</p></li></ol><pre><code class="bash">git remote add origin https://github.com/Elinpf/Elinpf.github.io.gitgit push origin mastergit branch -M gh-pagesgit push origin gh-pages</code></pre><ol start="5"><li>将<code>Setting</code>中的Pages发布源改为<code>gh-pages</code>分支</li></ol><p><img src="/2021/06/22/github-pages-%E9%83%A8%E7%BD%B2/1.png"></p><ol start="6"><li>将<code>Setting</code>中的<code>Secrets</code>添加一个<code>ACCESS_TOKEN</code>(这里的token就是用户授权的token值，<a href="https://docs.github.com/en/github/authenticating-to-github/keeping-your-account-and-data-secure/creating-a-personal-access-token">参考这里增加新的授权</a>)</li></ol><p><img src="/2021/06/22/github-pages-%E9%83%A8%E7%BD%B2/2.png"></p><ol start="7"><li>在项目中添加文件<code>.github/workflows/docusaurus.yml</code>，来写Action用于自动部署（具体含义参考<a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">这篇文章</a>）</li></ol><pre><code class="yaml">name: Deploy Github pageson:  push:    branches:      - masterjobs:  build-and-deploy:    runs-on: ubuntu-latest    steps:    - name: Checkout      uses: actions/checkout@master      with:        persist-credentials: false    - name: Install and Build      run: |        npm install        npm run-script build     - name: Deploy      uses: JamesIves/github-pages-deploy-action@releases/v3      with:        ACCESS_TOKEN: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;        BRANCH: gh-pages        FOLDER: build        BUILD_SCRIPT: npm install &amp;&amp; npm run build</code></pre><ol start="8"><li>再次提交就可以了</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> docusaurus </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
